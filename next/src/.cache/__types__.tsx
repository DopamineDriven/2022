/* add110329d2f1934c234cf192d6a0d4a323b6d0b
 * This file is automatically generated by graphql-let. */

import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** The `BigInt` scalar type represents non-fractional signed whole numeric values. */
  BigInt: any;
  /** A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format. */
  DateTime: any;
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: any;
  /** The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSONObject: any;
  /** A field whose value conforms to the standard E.164 format as specified in: https://en.wikipedia.org/wiki/E.164. Basically this is +17895551234. */
  PhoneNumber: any;
};

export type Account = {
  __typename?: 'Account';
  access_token?: Maybe<Scalars['String']>;
  expires_at?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  id_token?: Maybe<Scalars['String']>;
  oauth_token?: Maybe<Scalars['String']>;
  oauth_token_secret?: Maybe<Scalars['String']>;
  provider: Scalars['String'];
  providerAccountId: Scalars['String'];
  refresh_secret?: Maybe<Scalars['String']>;
  refresh_token?: Maybe<Scalars['String']>;
  scope?: Maybe<Scalars['String']>;
  session_state?: Maybe<Scalars['String']>;
  token_type?: Maybe<Scalars['String']>;
  type: Scalars['String'];
  user: User;
  userId: Scalars['String'];
};

export type AccountCreateManyUserInput = {
  access_token?: InputMaybe<Scalars['String']>;
  expires_at?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  id_token?: InputMaybe<Scalars['String']>;
  oauth_token?: InputMaybe<Scalars['String']>;
  oauth_token_secret?: InputMaybe<Scalars['String']>;
  provider: Scalars['String'];
  providerAccountId: Scalars['String'];
  refresh_secret?: InputMaybe<Scalars['String']>;
  refresh_token?: InputMaybe<Scalars['String']>;
  scope?: InputMaybe<Scalars['String']>;
  session_state?: InputMaybe<Scalars['String']>;
  token_type?: InputMaybe<Scalars['String']>;
  type: Scalars['String'];
};

export type AccountCreateManyUserInputEnvelope = {
  data: Array<AccountCreateManyUserInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type AccountCreateNestedManyWithoutUserInput = {
  connect?: InputMaybe<Array<AccountWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<AccountCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<AccountCreateWithoutUserInput>>;
  createMany?: InputMaybe<AccountCreateManyUserInputEnvelope>;
};

export type AccountCreateOrConnectWithoutUserInput = {
  create: AccountCreateWithoutUserInput;
  where: AccountWhereUniqueInput;
};

export type AccountCreateWithoutUserInput = {
  access_token?: InputMaybe<Scalars['String']>;
  expires_at?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  id_token?: InputMaybe<Scalars['String']>;
  oauth_token?: InputMaybe<Scalars['String']>;
  oauth_token_secret?: InputMaybe<Scalars['String']>;
  provider: Scalars['String'];
  providerAccountId: Scalars['String'];
  refresh_secret?: InputMaybe<Scalars['String']>;
  refresh_token?: InputMaybe<Scalars['String']>;
  scope?: InputMaybe<Scalars['String']>;
  session_state?: InputMaybe<Scalars['String']>;
  token_type?: InputMaybe<Scalars['String']>;
  type: Scalars['String'];
};

export type AccountOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type AccountProviderProviderAccountIdCompoundUniqueInput = {
  provider: Scalars['String'];
  providerAccountId: Scalars['String'];
};

export type AccountWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
  provider_providerAccountId?: InputMaybe<AccountProviderProviderAccountIdCompoundUniqueInput>;
};

export enum AlgorithmType {
  Es256 = 'ES256',
  Es256K = 'ES256K',
  Es384 = 'ES384',
  Es512 = 'ES512',
  Ed448 = 'Ed448',
  Ed25519 = 'Ed25519',
  Hs256 = 'HS256',
  Hs384 = 'HS384',
  Hs512 = 'HS512',
  None = 'None',
  Ps256 = 'PS256',
  Ps384 = 'PS384',
  Ps512 = 'PS512',
  Rs256 = 'RS256',
  Rs384 = 'RS384',
  Rs512 = 'RS512'
}

export type Auth = {
  __typename?: 'Auth';
  accessToken?: Maybe<Scalars['String']>;
  refreshToken?: Maybe<Scalars['String']>;
  session?: Maybe<Session>;
  user?: Maybe<User>;
};

export type AuthDetailed = {
  __typename?: 'AuthDetailed';
  auth?: Maybe<Auth>;
  jwt?: Maybe<JwtDecoded>;
};

export type AuthSansSession = {
  __typename?: 'AuthSansSession';
  accessToken?: Maybe<Scalars['String']>;
  refreshToken?: Maybe<Scalars['String']>;
  user?: Maybe<User>;
};

export type Category = {
  __typename?: 'Category';
  _count: CategoryCount;
  createdAt?: Maybe<Scalars['DateTime']>;
  creator: User;
  creatorId: Scalars['String'];
  entries?: Maybe<Array<Entry>>;
  entryId?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CategoryCount = {
  __typename?: 'CategoryCount';
  entries: Scalars['Int'];
};

export type CategoryCreateManyCreatorInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  entryId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CategoryCreateManyCreatorInputEnvelope = {
  data: Array<CategoryCreateManyCreatorInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type CategoryCreateNestedManyWithoutCreatorInput = {
  connect?: InputMaybe<Array<CategoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CategoryCreateOrConnectWithoutCreatorInput>>;
  create?: InputMaybe<Array<CategoryCreateWithoutCreatorInput>>;
  createMany?: InputMaybe<CategoryCreateManyCreatorInputEnvelope>;
};

export type CategoryCreateNestedManyWithoutEntriesInput = {
  connect?: InputMaybe<Array<CategoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CategoryCreateOrConnectWithoutEntriesInput>>;
  create?: InputMaybe<Array<CategoryCreateWithoutEntriesInput>>;
};

export type CategoryCreateOrConnectWithoutCreatorInput = {
  create: CategoryCreateWithoutCreatorInput;
  where: CategoryWhereUniqueInput;
};

export type CategoryCreateOrConnectWithoutEntriesInput = {
  create: CategoryCreateWithoutEntriesInput;
  where: CategoryWhereUniqueInput;
};

export type CategoryCreateWithoutCreatorInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  entries?: InputMaybe<EntryCreateNestedManyWithoutCategoriesInput>;
  entryId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CategoryCreateWithoutEntriesInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  creator: UserCreateNestedOneWithoutCategoriesInput;
  entryId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CategoryOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type CategoryWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};

export type ChangePasswordInput = {
  newPassword: Scalars['String'];
  oldPassword: Scalars['String'];
};

export type Comment = {
  __typename?: 'Comment';
  author: User;
  authorId: Scalars['String'];
  body?: Maybe<Scalars['JSONObject']>;
  createdAt: Scalars['DateTime'];
  entry: Entry;
  entryId: Scalars['String'];
  id: Scalars['ID'];
  position?: Maybe<Scalars['String']>;
  reactions?: Maybe<Array<CommentReactions>>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CommentCreateManyAuthorInput = {
  body?: InputMaybe<Scalars['JSON']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  entryId: Scalars['String'];
  id?: InputMaybe<Scalars['String']>;
  position?: InputMaybe<Scalars['String']>;
  reactions?: InputMaybe<CommentCreateManyreactionsInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CommentCreateManyAuthorInputEnvelope = {
  data: Array<CommentCreateManyAuthorInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type CommentCreateManyEntryInput = {
  authorId: Scalars['String'];
  body?: InputMaybe<Scalars['JSON']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['String']>;
  position?: InputMaybe<Scalars['String']>;
  reactions?: InputMaybe<CommentCreateManyreactionsInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CommentCreateManyEntryInputEnvelope = {
  data: Array<CommentCreateManyEntryInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type CommentCreateManyreactionsInput = {
  set: Array<CommentReactions>;
};

export type CommentCreateNestedManyWithoutAuthorInput = {
  connect?: InputMaybe<Array<CommentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CommentCreateOrConnectWithoutAuthorInput>>;
  create?: InputMaybe<Array<CommentCreateWithoutAuthorInput>>;
  createMany?: InputMaybe<CommentCreateManyAuthorInputEnvelope>;
};

export type CommentCreateNestedManyWithoutEntryInput = {
  connect?: InputMaybe<Array<CommentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CommentCreateOrConnectWithoutEntryInput>>;
  create?: InputMaybe<Array<CommentCreateWithoutEntryInput>>;
  createMany?: InputMaybe<CommentCreateManyEntryInputEnvelope>;
};

export type CommentCreateOrConnectWithoutAuthorInput = {
  create: CommentCreateWithoutAuthorInput;
  where: CommentWhereUniqueInput;
};

export type CommentCreateOrConnectWithoutEntryInput = {
  create: CommentCreateWithoutEntryInput;
  where: CommentWhereUniqueInput;
};

export type CommentCreateWithoutAuthorInput = {
  body?: InputMaybe<Scalars['JSON']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  entry: EntryCreateNestedOneWithoutCommentsInput;
  id?: InputMaybe<Scalars['String']>;
  position?: InputMaybe<Scalars['String']>;
  reactions?: InputMaybe<CommentCreatereactionsInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CommentCreateWithoutEntryInput = {
  author: UserCreateNestedOneWithoutCommentsInput;
  body?: InputMaybe<Scalars['JSON']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['String']>;
  position?: InputMaybe<Scalars['String']>;
  reactions?: InputMaybe<CommentCreatereactionsInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CommentCreatereactionsInput = {
  set: Array<CommentReactions>;
};

export type CommentOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum CommentReactions {
  Angry = 'ANGRY',
  Care = 'CARE',
  Confused = 'CONFUSED',
  Dislike = 'DISLIKE',
  Laugh = 'LAUGH',
  Like = 'LIKE',
  Love = 'LOVE',
  Parrot = 'PARROT',
  Rocket = 'ROCKET',
  Tears = 'TEARS',
  Wow = 'WOW'
}

export type CommentWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
};

export type Connection = {
  __typename?: 'Connection';
  email: Scalars['String'];
  firstName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  ip?: Maybe<Scalars['String']>;
  lastModified?: Maybe<Scalars['DateTime']>;
  lastName?: Maybe<Scalars['String']>;
  owner: User;
  ownerId: Scalars['String'];
  phoneNumber?: Maybe<Scalars['PhoneNumber']>;
};

export type ConnectionCreateManyOwnerInput = {
  email: Scalars['String'];
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  ip?: InputMaybe<Scalars['String']>;
  lastModified?: InputMaybe<Scalars['DateTime']>;
  lastName?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
};

export type ConnectionCreateManyOwnerInputEnvelope = {
  data: Array<ConnectionCreateManyOwnerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type ConnectionCreateNestedManyWithoutOwnerInput = {
  connect?: InputMaybe<Array<ConnectionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConnectionCreateOrConnectWithoutOwnerInput>>;
  create?: InputMaybe<Array<ConnectionCreateWithoutOwnerInput>>;
  createMany?: InputMaybe<ConnectionCreateManyOwnerInputEnvelope>;
};

export type ConnectionCreateOrConnectWithoutOwnerInput = {
  create: ConnectionCreateWithoutOwnerInput;
  where: ConnectionWhereUniqueInput;
};

export type ConnectionCreateWithoutOwnerInput = {
  email: Scalars['String'];
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  ip?: InputMaybe<Scalars['String']>;
  lastModified?: InputMaybe<Scalars['DateTime']>;
  lastName?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
};

export type ConnectionOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ConnectionWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
};

export type Entry = {
  __typename?: 'Entry';
  _count: EntryCount;
  author: User;
  authorId: Scalars['String'];
  categories?: Maybe<Array<Category>>;
  categoryId?: Maybe<Scalars['String']>;
  comments?: Maybe<Array<Comment>>;
  content?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  featuredImage?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  published?: Maybe<Scalars['Boolean']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type EntryConnection = {
  __typename?: 'EntryConnection';
  edges: Array<EntryEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type EntryCount = {
  __typename?: 'EntryCount';
  categories: Scalars['Int'];
  comments: Scalars['Int'];
};

export type EntryCreateInput = {
  author: UserCreateNestedOneWithoutEntriesInput;
  categories?: InputMaybe<CategoryCreateNestedManyWithoutEntriesInput>;
  categoryId?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<CommentCreateNestedManyWithoutEntryInput>;
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  featuredImage?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Boolean']>;
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type EntryCreateManyAuthorInput = {
  categoryId?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  featuredImage?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Boolean']>;
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type EntryCreateManyAuthorInputEnvelope = {
  data: Array<EntryCreateManyAuthorInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type EntryCreateNestedManyWithoutAuthorInput = {
  connect?: InputMaybe<Array<EntryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EntryCreateOrConnectWithoutAuthorInput>>;
  create?: InputMaybe<Array<EntryCreateWithoutAuthorInput>>;
  createMany?: InputMaybe<EntryCreateManyAuthorInputEnvelope>;
};

export type EntryCreateNestedManyWithoutCategoriesInput = {
  connect?: InputMaybe<Array<EntryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EntryCreateOrConnectWithoutCategoriesInput>>;
  create?: InputMaybe<Array<EntryCreateWithoutCategoriesInput>>;
};

export type EntryCreateNestedOneWithoutCommentsInput = {
  connect?: InputMaybe<EntryWhereUniqueInput>;
  connectOrCreate?: InputMaybe<EntryCreateOrConnectWithoutCommentsInput>;
  create?: InputMaybe<EntryCreateWithoutCommentsInput>;
};

export type EntryCreateOrConnectWithoutAuthorInput = {
  create: EntryCreateWithoutAuthorInput;
  where: EntryWhereUniqueInput;
};

export type EntryCreateOrConnectWithoutCategoriesInput = {
  create: EntryCreateWithoutCategoriesInput;
  where: EntryWhereUniqueInput;
};

export type EntryCreateOrConnectWithoutCommentsInput = {
  create: EntryCreateWithoutCommentsInput;
  where: EntryWhereUniqueInput;
};

export type EntryCreateWithoutAuthorInput = {
  categories?: InputMaybe<CategoryCreateNestedManyWithoutEntriesInput>;
  categoryId?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<CommentCreateNestedManyWithoutEntryInput>;
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  featuredImage?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Boolean']>;
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type EntryCreateWithoutCategoriesInput = {
  author: UserCreateNestedOneWithoutEntriesInput;
  categoryId?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<CommentCreateNestedManyWithoutEntryInput>;
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  featuredImage?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Boolean']>;
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type EntryCreateWithoutCommentsInput = {
  author: UserCreateNestedOneWithoutEntriesInput;
  categories?: InputMaybe<CategoryCreateNestedManyWithoutEntriesInput>;
  categoryId?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  featuredImage?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Boolean']>;
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type EntryEdge = {
  __typename?: 'EntryEdge';
  cursor: Scalars['String'];
  node: Entry;
};

export type EntryOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EntryOrderByRelevanceFieldEnum {
  AuthorId = 'authorId',
  CategoryId = 'categoryId',
  Content = 'content',
  FeaturedImage = 'featuredImage',
  Id = 'id',
  Title = 'title'
}

export type EntryOrderByRelevanceInput = {
  fields: Array<EntryOrderByRelevanceFieldEnum>;
  search: Scalars['String'];
  sort: SortOrder;
};

export type EntryOrderByWithRelationAndSearchRelevanceInput = {
  _relevance?: InputMaybe<EntryOrderByRelevanceInput>;
  author?: InputMaybe<UserOrderByWithRelationAndSearchRelevanceInput>;
  authorId?: InputMaybe<SortOrder>;
  categories?: InputMaybe<CategoryOrderByRelationAggregateInput>;
  categoryId?: InputMaybe<SortOrder>;
  comments?: InputMaybe<CommentOrderByRelationAggregateInput>;
  content?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  featuredImage?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  published?: InputMaybe<SortOrder>;
  title?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type EntryWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type EnumGenderNullableFilter = {
  equals?: InputMaybe<Gender>;
  in?: InputMaybe<Array<Gender>>;
  not?: InputMaybe<NestedEnumGenderNullableFilter>;
  notIn?: InputMaybe<Array<Gender>>;
};

export type EnumPronounsNullableFilter = {
  equals?: InputMaybe<Pronouns>;
  in?: InputMaybe<Array<Pronouns>>;
  not?: InputMaybe<NestedEnumPronounsNullableFilter>;
  notIn?: InputMaybe<Array<Pronouns>>;
};

export type EnumRoleNullableFilter = {
  equals?: InputMaybe<Role>;
  in?: InputMaybe<Array<Role>>;
  not?: InputMaybe<NestedEnumRoleNullableFilter>;
  notIn?: InputMaybe<Array<Role>>;
};

export type EnumUserStatusNullableFilter = {
  equals?: InputMaybe<UserStatus>;
  in?: InputMaybe<Array<UserStatus>>;
  not?: InputMaybe<NestedEnumUserStatusNullableFilter>;
  notIn?: InputMaybe<Array<UserStatus>>;
};

export enum Gender {
  Female = 'FEMALE',
  Male = 'MALE',
  Other = 'OTHER',
  Uncertain = 'UNCERTAIN'
}

export type JsonNullableFilter = {
  array_contains?: InputMaybe<Scalars['JSON']>;
  array_ends_with?: InputMaybe<Scalars['JSON']>;
  array_starts_with?: InputMaybe<Scalars['JSON']>;
  equals?: InputMaybe<Scalars['JSON']>;
  gt?: InputMaybe<Scalars['JSON']>;
  gte?: InputMaybe<Scalars['JSON']>;
  lt?: InputMaybe<Scalars['JSON']>;
  lte?: InputMaybe<Scalars['JSON']>;
  not?: InputMaybe<Scalars['JSON']>;
  path?: InputMaybe<Array<Scalars['String']>>;
  string_contains?: InputMaybe<Scalars['String']>;
  string_ends_with?: InputMaybe<Scalars['String']>;
  string_starts_with?: InputMaybe<Scalars['String']>;
};

export type JwtDecoded = {
  __typename?: 'JwtDecoded';
  header: JwtHeaders;
  payload: JwtPayload;
  signature: Scalars['String'];
};

export type JwtHeaders = {
  __typename?: 'JwtHeaders';
  alg: AlgorithmType;
  typ: Scalars['String'];
};

export type JwtPayload = {
  __typename?: 'JwtPayload';
  exp?: Maybe<Scalars['BigInt']>;
  iat?: Maybe<Scalars['BigInt']>;
  userId?: Maybe<Scalars['String']>;
};

export type LoginInput = {
  email?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
};

export type ManyUsersPaginatedArgs = {
  emailFilter: StringFilter;
  firstNameFilter: StringNullableFilter;
  lastNameFilter: StringNullableFilter;
  orderByRelevance: Array<UserOrderByWithRelationAndSearchRelevanceInput>;
  paginationArgs: PaginationArgsInput;
  roles: EnumRoleNullableFilter;
  userStatus: EnumUserStatusNullableFilter;
};

export type Mutation = {
  __typename?: 'Mutation';
  changePassword: User;
  createEntry: Entry;
  createProfile: Profile;
  getUserFromAccessToken: User;
  login: Token;
  refreshToken: Token;
  register: AuthSansSession;
  signin: AuthDetailed;
  signup: Token;
};


export type MutationChangePasswordArgs = {
  accessToken: Scalars['String'];
  data: ChangePasswordInput;
};


export type MutationCreateEntryArgs = {
  data: EntryCreateInput;
};


export type MutationCreateProfileArgs = {
  data: ProfileCreateInput;
  userId: Scalars['String'];
};


export type MutationGetUserFromAccessTokenArgs = {
  token: Scalars['String'];
};


export type MutationLoginArgs = {
  data: LoginInput;
};


export type MutationRefreshTokenArgs = {
  token: Scalars['String'];
};


export type MutationRegisterArgs = {
  dataRegister: SignupInput;
};


export type MutationSignupArgs = {
  data: SignupInput;
};

export type NestedEnumGenderNullableFilter = {
  equals?: InputMaybe<Gender>;
  in?: InputMaybe<Array<Gender>>;
  not?: InputMaybe<NestedEnumGenderNullableFilter>;
  notIn?: InputMaybe<Array<Gender>>;
};

export type NestedEnumPronounsNullableFilter = {
  equals?: InputMaybe<Pronouns>;
  in?: InputMaybe<Array<Pronouns>>;
  not?: InputMaybe<NestedEnumPronounsNullableFilter>;
  notIn?: InputMaybe<Array<Pronouns>>;
};

export type NestedEnumRoleNullableFilter = {
  equals?: InputMaybe<Role>;
  in?: InputMaybe<Array<Role>>;
  not?: InputMaybe<NestedEnumRoleNullableFilter>;
  notIn?: InputMaybe<Array<Role>>;
};

export type NestedEnumUserStatusNullableFilter = {
  equals?: InputMaybe<UserStatus>;
  in?: InputMaybe<Array<UserStatus>>;
  not?: InputMaybe<NestedEnumUserStatusNullableFilter>;
  notIn?: InputMaybe<Array<UserStatus>>;
};

export type NestedStringFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  search?: InputMaybe<Scalars['String']>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type NestedStringNullableFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  search?: InputMaybe<Scalars['String']>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor?: Maybe<Scalars['String']>;
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor?: Maybe<Scalars['String']>;
};

export type PaginationArgsInput = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
};

export type Profile = {
  __typename?: 'Profile';
  activiyFeed?: Maybe<Array<Scalars['JSON']>>;
  bio?: Maybe<Array<Scalars['JSON']>>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  coverPhoto?: Maybe<Scalars['String']>;
  dob?: Maybe<Scalars['String']>;
  gender?: Maybe<Gender>;
  id: Scalars['ID'];
  lastSeen?: Maybe<Scalars['DateTime']>;
  memberSince: Scalars['DateTime'];
  occupation?: Maybe<Scalars['String']>;
  phoneNumber?: Maybe<Scalars['String']>;
  pronouns?: Maybe<Pronouns>;
  recentActivity?: Maybe<Array<Scalars['JSON']>>;
  user: User;
  userId: Scalars['String'];
  userInProfile: User;
};

export type ProfileConnection = {
  __typename?: 'ProfileConnection';
  edges: Array<ProfileEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ProfileCreateInput = {
  activiyFeed?: InputMaybe<ProfileCreateactiviyFeedInput>;
  bio?: InputMaybe<ProfileCreatebioInput>;
  city?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  coverPhoto?: InputMaybe<Scalars['String']>;
  dob?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<Gender>;
  id?: InputMaybe<Scalars['String']>;
  lastSeen?: InputMaybe<Scalars['DateTime']>;
  memberSince?: InputMaybe<Scalars['DateTime']>;
  occupation?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  pronouns?: InputMaybe<Pronouns>;
  recentActivity?: InputMaybe<ProfileCreaterecentActivityInput>;
  user: UserCreateNestedOneWithoutProfileInput;
};

export type ProfileCreateNestedOneWithoutUserInput = {
  connect?: InputMaybe<ProfileWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProfileCreateOrConnectWithoutUserInput>;
  create?: InputMaybe<ProfileCreateWithoutUserInput>;
};

export type ProfileCreateOrConnectWithoutUserInput = {
  create: ProfileCreateWithoutUserInput;
  where: ProfileWhereUniqueInput;
};

export type ProfileCreateWithoutUserInput = {
  activiyFeed?: InputMaybe<ProfileCreateactiviyFeedInput>;
  bio?: InputMaybe<ProfileCreatebioInput>;
  city?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  coverPhoto?: InputMaybe<Scalars['String']>;
  dob?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<Gender>;
  id?: InputMaybe<Scalars['String']>;
  lastSeen?: InputMaybe<Scalars['DateTime']>;
  memberSince?: InputMaybe<Scalars['DateTime']>;
  occupation?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  pronouns?: InputMaybe<Pronouns>;
  recentActivity?: InputMaybe<ProfileCreaterecentActivityInput>;
};

export type ProfileCreateactiviyFeedInput = {
  set: Array<Scalars['JSON']>;
};

export type ProfileCreatebioInput = {
  set: Array<Scalars['JSON']>;
};

export type ProfileCreaterecentActivityInput = {
  set: Array<Scalars['JSON']>;
};

export type ProfileEdge = {
  __typename?: 'ProfileEdge';
  cursor: Scalars['String'];
  node: Profile;
};

export enum ProfileOrderByRelevanceFieldEnum {
  City = 'city',
  Country = 'country',
  CoverPhoto = 'coverPhoto',
  Dob = 'dob',
  Id = 'id',
  Occupation = 'occupation',
  PhoneNumber = 'phoneNumber',
  UserId = 'userId'
}

export type ProfileOrderByRelevanceInput = {
  fields: Array<ProfileOrderByRelevanceFieldEnum>;
  search: Scalars['String'];
  sort: SortOrder;
};

export type ProfileOrderByWithRelationAndSearchRelevanceInput = {
  _relevance?: InputMaybe<ProfileOrderByRelevanceInput>;
  activiyFeed?: InputMaybe<SortOrder>;
  bio?: InputMaybe<SortOrder>;
  city?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  coverPhoto?: InputMaybe<SortOrder>;
  dob?: InputMaybe<SortOrder>;
  gender?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastSeen?: InputMaybe<SortOrder>;
  memberSince?: InputMaybe<SortOrder>;
  occupation?: InputMaybe<SortOrder>;
  phoneNumber?: InputMaybe<SortOrder>;
  pronouns?: InputMaybe<SortOrder>;
  recentActivity?: InputMaybe<SortOrder>;
  user?: InputMaybe<UserOrderByWithRelationAndSearchRelevanceInput>;
  userId?: InputMaybe<SortOrder>;
};

export type ProfileWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['String']>;
};

export type ProfilesInput = {
  bioFilter?: InputMaybe<JsonNullableFilter>;
  dobFilter?: InputMaybe<StringNullableFilter>;
  genderFilter?: InputMaybe<EnumGenderNullableFilter>;
  orderBy?: InputMaybe<ProfileOrderByWithRelationAndSearchRelevanceInput>;
  paginationArgs?: InputMaybe<PaginationArgsInput>;
  pronounsFilter?: InputMaybe<EnumPronounsNullableFilter>;
};

export enum Pronouns {
  HeHimHis = 'HE_HIM_HIS',
  NotListed = 'NOT_LISTED',
  PreferNotToSay = 'PREFER_NOT_TO_SAY',
  SheHerHers = 'SHE_HER_HERS',
  TheyThemTheirs = 'THEY_THEM_THEIRS'
}

export type Query = {
  __typename?: 'Query';
  entryById: Entry;
  entryCursorConnection: EntryConnection;
  getProfiles: ProfileConnection;
  getViewer: Viewer;
  hello: Scalars['String'];
  helloWorld: Scalars['String'];
  listUsers: UserConnection;
  me: AuthDetailed;
  profileByRelayId: Profile;
  profiles: ProfileConnection;
  userById: User;
  userByRelayId: User;
  userPosts: Array<Entry>;
};


export type QueryEntryByIdArgs = {
  id: Scalars['String'];
};


export type QueryEntryCursorConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<EntryOrderByWithRelationAndSearchRelevanceInput>;
  query?: InputMaybe<Scalars['String']>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type QueryGetProfilesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ProfileOrderByWithRelationAndSearchRelevanceInput>;
  query?: InputMaybe<Scalars['String']>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type QueryGetViewerArgs = {
  id: Scalars['String'];
};


export type QueryHelloArgs = {
  name: Scalars['String'];
};


export type QueryListUsersArgs = {
  ManyUsersPaginatedArgs?: InputMaybe<ManyUsersPaginatedArgs>;
};


export type QueryProfilesArgs = {
  profilesArgs: ProfilesInput;
};


export type QueryUserByIdArgs = {
  id: Scalars['String'];
};


export type QueryUserPostsArgs = {
  userId: Scalars['ID'];
};

export enum QueryMode {
  Default = 'default',
  Insensitive = 'insensitive'
}

export enum Role {
  Admin = 'ADMIN',
  Maintainer = 'MAINTAINER',
  Superadmin = 'SUPERADMIN',
  User = 'USER'
}

export type Session = {
  __typename?: 'Session';
  accessToken?: Maybe<Scalars['String']>;
  alg?: Maybe<Scalars['String']>;
  exp?: Maybe<Scalars['Int']>;
  iat?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  lastVerified?: Maybe<Scalars['DateTime']>;
  provider?: Maybe<Scalars['String']>;
  refreshToken?: Maybe<Scalars['String']>;
  scopes?: Maybe<Array<Scalars['String']>>;
  signature?: Maybe<Scalars['String']>;
  tokenState?: Maybe<Scalars['String']>;
  user?: Maybe<User>;
  userId: Scalars['String'];
};

export type SessionCreateManyUserInput = {
  accessToken?: InputMaybe<Scalars['String']>;
  alg?: InputMaybe<Scalars['String']>;
  exp?: InputMaybe<Scalars['Int']>;
  iat?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  lastVerified?: InputMaybe<Scalars['DateTime']>;
  provider?: InputMaybe<Scalars['String']>;
  refreshToken?: InputMaybe<Scalars['String']>;
  scopes?: InputMaybe<SessionCreateManyscopesInput>;
  signature?: InputMaybe<Scalars['String']>;
  tokenState?: InputMaybe<Scalars['String']>;
};

export type SessionCreateManyUserInputEnvelope = {
  data: Array<SessionCreateManyUserInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type SessionCreateManyscopesInput = {
  set: Array<Scalars['String']>;
};

export type SessionCreateNestedManyWithoutUserInput = {
  connect?: InputMaybe<Array<SessionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SessionCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<SessionCreateWithoutUserInput>>;
  createMany?: InputMaybe<SessionCreateManyUserInputEnvelope>;
};

export type SessionCreateOrConnectWithoutUserInput = {
  create: SessionCreateWithoutUserInput;
  where: SessionWhereUniqueInput;
};

export type SessionCreateWithoutUserInput = {
  accessToken?: InputMaybe<Scalars['String']>;
  alg?: InputMaybe<Scalars['String']>;
  exp?: InputMaybe<Scalars['Int']>;
  iat?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  lastVerified?: InputMaybe<Scalars['DateTime']>;
  provider?: InputMaybe<Scalars['String']>;
  refreshToken?: InputMaybe<Scalars['String']>;
  scopes?: InputMaybe<SessionCreatescopesInput>;
  signature?: InputMaybe<Scalars['String']>;
  tokenState?: InputMaybe<Scalars['String']>;
};

export type SessionCreatescopesInput = {
  set: Array<Scalars['String']>;
};

export type SessionOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type SessionWhereUniqueInput = {
  userId?: InputMaybe<Scalars['String']>;
};

export type SignupInput = {
  email: Scalars['String'];
  firstName?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  password: Scalars['String'];
};

export enum SortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type StringFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  search?: InputMaybe<Scalars['String']>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type StringNullableFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  search?: InputMaybe<Scalars['String']>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type Subscription = {
  __typename?: 'Subscription';
  entryCreated: Entry;
  profileCreated: Profile;
};

export type Token = {
  __typename?: 'Token';
  /** JWT access token */
  accessToken?: Maybe<Scalars['String']>;
  /** JWT refresh token */
  refreshToken?: Maybe<Scalars['String']>;
};

export type User = {
  __typename?: 'User';
  accounts?: Maybe<Array<Account>>;
  categories?: Maybe<Array<Category>>;
  comments?: Maybe<Array<Comment>>;
  connections?: Maybe<Array<Connection>>;
  /** Identifies the date and time when the user was created. */
  createdAt: Scalars['DateTime'];
  email: Scalars['String'];
  emailVerified?: Maybe<Scalars['DateTime']>;
  entries?: Maybe<Array<Entry>>;
  firstName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  image?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password: Scalars['String'];
  profile?: Maybe<Profile>;
  role?: Maybe<Role>;
  sessions?: Maybe<Array<Session>>;
  status: UserStatus;
  /** Identifies the date and time when the user was last updated. */
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type UserConnection = {
  __typename?: 'UserConnection';
  edges: Array<UserEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type UserCreateNestedOneWithoutCategoriesInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutCategoriesInput>;
  create?: InputMaybe<UserCreateWithoutCategoriesInput>;
};

export type UserCreateNestedOneWithoutCommentsInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutCommentsInput>;
  create?: InputMaybe<UserCreateWithoutCommentsInput>;
};

export type UserCreateNestedOneWithoutEntriesInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutEntriesInput>;
  create?: InputMaybe<UserCreateWithoutEntriesInput>;
};

export type UserCreateNestedOneWithoutProfileInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutProfileInput>;
  create?: InputMaybe<UserCreateWithoutProfileInput>;
};

export type UserCreateOrConnectWithoutCategoriesInput = {
  create: UserCreateWithoutCategoriesInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutCommentsInput = {
  create: UserCreateWithoutCommentsInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutEntriesInput = {
  create: UserCreateWithoutEntriesInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutProfileInput = {
  create: UserCreateWithoutProfileInput;
  where: UserWhereUniqueInput;
};

export type UserCreateWithoutCategoriesInput = {
  accounts?: InputMaybe<AccountCreateNestedManyWithoutUserInput>;
  comments?: InputMaybe<CommentCreateNestedManyWithoutAuthorInput>;
  connections?: InputMaybe<ConnectionCreateNestedManyWithoutOwnerInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  email: Scalars['String'];
  emailVerified?: InputMaybe<Scalars['DateTime']>;
  entries?: InputMaybe<EntryCreateNestedManyWithoutAuthorInput>;
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  profile?: InputMaybe<ProfileCreateNestedOneWithoutUserInput>;
  role?: InputMaybe<Role>;
  sessions?: InputMaybe<SessionCreateNestedManyWithoutUserInput>;
  status?: InputMaybe<UserStatus>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type UserCreateWithoutCommentsInput = {
  accounts?: InputMaybe<AccountCreateNestedManyWithoutUserInput>;
  categories?: InputMaybe<CategoryCreateNestedManyWithoutCreatorInput>;
  connections?: InputMaybe<ConnectionCreateNestedManyWithoutOwnerInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  email: Scalars['String'];
  emailVerified?: InputMaybe<Scalars['DateTime']>;
  entries?: InputMaybe<EntryCreateNestedManyWithoutAuthorInput>;
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  profile?: InputMaybe<ProfileCreateNestedOneWithoutUserInput>;
  role?: InputMaybe<Role>;
  sessions?: InputMaybe<SessionCreateNestedManyWithoutUserInput>;
  status?: InputMaybe<UserStatus>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type UserCreateWithoutEntriesInput = {
  accounts?: InputMaybe<AccountCreateNestedManyWithoutUserInput>;
  categories?: InputMaybe<CategoryCreateNestedManyWithoutCreatorInput>;
  comments?: InputMaybe<CommentCreateNestedManyWithoutAuthorInput>;
  connections?: InputMaybe<ConnectionCreateNestedManyWithoutOwnerInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  email: Scalars['String'];
  emailVerified?: InputMaybe<Scalars['DateTime']>;
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  profile?: InputMaybe<ProfileCreateNestedOneWithoutUserInput>;
  role?: InputMaybe<Role>;
  sessions?: InputMaybe<SessionCreateNestedManyWithoutUserInput>;
  status?: InputMaybe<UserStatus>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type UserCreateWithoutProfileInput = {
  accounts?: InputMaybe<AccountCreateNestedManyWithoutUserInput>;
  categories?: InputMaybe<CategoryCreateNestedManyWithoutCreatorInput>;
  comments?: InputMaybe<CommentCreateNestedManyWithoutAuthorInput>;
  connections?: InputMaybe<ConnectionCreateNestedManyWithoutOwnerInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  email: Scalars['String'];
  emailVerified?: InputMaybe<Scalars['DateTime']>;
  entries?: InputMaybe<EntryCreateNestedManyWithoutAuthorInput>;
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Role>;
  sessions?: InputMaybe<SessionCreateNestedManyWithoutUserInput>;
  status?: InputMaybe<UserStatus>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type UserEdge = {
  __typename?: 'UserEdge';
  cursor: Scalars['String'];
  node: User;
};

export enum UserOrderByRelevanceFieldEnum {
  Email = 'email',
  FirstName = 'firstName',
  Id = 'id',
  Image = 'image',
  LastName = 'lastName',
  Password = 'password'
}

export type UserOrderByRelevanceInput = {
  fields: Array<UserOrderByRelevanceFieldEnum>;
  search: Scalars['String'];
  sort: SortOrder;
};

export type UserOrderByWithRelationAndSearchRelevanceInput = {
  _relevance?: InputMaybe<UserOrderByRelevanceInput>;
  accounts?: InputMaybe<AccountOrderByRelationAggregateInput>;
  categories?: InputMaybe<CategoryOrderByRelationAggregateInput>;
  comments?: InputMaybe<CommentOrderByRelationAggregateInput>;
  connections?: InputMaybe<ConnectionOrderByRelationAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  emailVerified?: InputMaybe<SortOrder>;
  entries?: InputMaybe<EntryOrderByRelationAggregateInput>;
  firstName?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  lastName?: InputMaybe<SortOrder>;
  password?: InputMaybe<SortOrder>;
  profile?: InputMaybe<ProfileOrderByWithRelationAndSearchRelevanceInput>;
  role?: InputMaybe<SortOrder>;
  sessions?: InputMaybe<SessionOrderByRelationAggregateInput>;
  status?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum UserStatus {
  Banned = 'BANNED',
  Deactivated = 'DEACTIVATED',
  Deleted = 'DELETED',
  Offline = 'OFFLINE',
  Online = 'ONLINE',
  Suspended = 'SUSPENDED'
}

export type UserWhereUniqueInput = {
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
};

export type Viewer = {
  __typename?: 'Viewer';
  accessToken?: Maybe<Scalars['String']>;
  accounts?: Maybe<Array<Account>>;
  categories?: Maybe<Array<Category>>;
  comments?: Maybe<Array<Comment>>;
  connections?: Maybe<Array<Connection>>;
  /** Identifies the date and time when the user was created. */
  createdAt: Scalars['DateTime'];
  email: Scalars['String'];
  emailVerified?: Maybe<Scalars['DateTime']>;
  entries?: Maybe<Array<Entry>>;
  firstName?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  image?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password: Scalars['String'];
  profile?: Maybe<Profile>;
  role?: Maybe<Role>;
  sessions?: Maybe<Array<Session>>;
  status: UserStatus;
  /** Identifies the date and time when the user was last updated. */
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  Account: ResolverTypeWrapper<Account>;
  AccountCreateManyUserInput: AccountCreateManyUserInput;
  AccountCreateManyUserInputEnvelope: AccountCreateManyUserInputEnvelope;
  AccountCreateNestedManyWithoutUserInput: AccountCreateNestedManyWithoutUserInput;
  AccountCreateOrConnectWithoutUserInput: AccountCreateOrConnectWithoutUserInput;
  AccountCreateWithoutUserInput: AccountCreateWithoutUserInput;
  AccountOrderByRelationAggregateInput: AccountOrderByRelationAggregateInput;
  AccountProviderProviderAccountIdCompoundUniqueInput: AccountProviderProviderAccountIdCompoundUniqueInput;
  AccountWhereUniqueInput: AccountWhereUniqueInput;
  AlgorithmType: AlgorithmType;
  Auth: ResolverTypeWrapper<Auth>;
  AuthDetailed: ResolverTypeWrapper<AuthDetailed>;
  AuthSansSession: ResolverTypeWrapper<AuthSansSession>;
  BigInt: ResolverTypeWrapper<Scalars['BigInt']>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  Category: ResolverTypeWrapper<Category>;
  CategoryCount: ResolverTypeWrapper<CategoryCount>;
  CategoryCreateManyCreatorInput: CategoryCreateManyCreatorInput;
  CategoryCreateManyCreatorInputEnvelope: CategoryCreateManyCreatorInputEnvelope;
  CategoryCreateNestedManyWithoutCreatorInput: CategoryCreateNestedManyWithoutCreatorInput;
  CategoryCreateNestedManyWithoutEntriesInput: CategoryCreateNestedManyWithoutEntriesInput;
  CategoryCreateOrConnectWithoutCreatorInput: CategoryCreateOrConnectWithoutCreatorInput;
  CategoryCreateOrConnectWithoutEntriesInput: CategoryCreateOrConnectWithoutEntriesInput;
  CategoryCreateWithoutCreatorInput: CategoryCreateWithoutCreatorInput;
  CategoryCreateWithoutEntriesInput: CategoryCreateWithoutEntriesInput;
  CategoryOrderByRelationAggregateInput: CategoryOrderByRelationAggregateInput;
  CategoryWhereUniqueInput: CategoryWhereUniqueInput;
  ChangePasswordInput: ChangePasswordInput;
  Comment: ResolverTypeWrapper<Comment>;
  CommentCreateManyAuthorInput: CommentCreateManyAuthorInput;
  CommentCreateManyAuthorInputEnvelope: CommentCreateManyAuthorInputEnvelope;
  CommentCreateManyEntryInput: CommentCreateManyEntryInput;
  CommentCreateManyEntryInputEnvelope: CommentCreateManyEntryInputEnvelope;
  CommentCreateManyreactionsInput: CommentCreateManyreactionsInput;
  CommentCreateNestedManyWithoutAuthorInput: CommentCreateNestedManyWithoutAuthorInput;
  CommentCreateNestedManyWithoutEntryInput: CommentCreateNestedManyWithoutEntryInput;
  CommentCreateOrConnectWithoutAuthorInput: CommentCreateOrConnectWithoutAuthorInput;
  CommentCreateOrConnectWithoutEntryInput: CommentCreateOrConnectWithoutEntryInput;
  CommentCreateWithoutAuthorInput: CommentCreateWithoutAuthorInput;
  CommentCreateWithoutEntryInput: CommentCreateWithoutEntryInput;
  CommentCreatereactionsInput: CommentCreatereactionsInput;
  CommentOrderByRelationAggregateInput: CommentOrderByRelationAggregateInput;
  CommentReactions: CommentReactions;
  CommentWhereUniqueInput: CommentWhereUniqueInput;
  Connection: ResolverTypeWrapper<Connection>;
  ConnectionCreateManyOwnerInput: ConnectionCreateManyOwnerInput;
  ConnectionCreateManyOwnerInputEnvelope: ConnectionCreateManyOwnerInputEnvelope;
  ConnectionCreateNestedManyWithoutOwnerInput: ConnectionCreateNestedManyWithoutOwnerInput;
  ConnectionCreateOrConnectWithoutOwnerInput: ConnectionCreateOrConnectWithoutOwnerInput;
  ConnectionCreateWithoutOwnerInput: ConnectionCreateWithoutOwnerInput;
  ConnectionOrderByRelationAggregateInput: ConnectionOrderByRelationAggregateInput;
  ConnectionWhereUniqueInput: ConnectionWhereUniqueInput;
  DateTime: ResolverTypeWrapper<Scalars['DateTime']>;
  Entry: ResolverTypeWrapper<Entry>;
  EntryConnection: ResolverTypeWrapper<EntryConnection>;
  EntryCount: ResolverTypeWrapper<EntryCount>;
  EntryCreateInput: EntryCreateInput;
  EntryCreateManyAuthorInput: EntryCreateManyAuthorInput;
  EntryCreateManyAuthorInputEnvelope: EntryCreateManyAuthorInputEnvelope;
  EntryCreateNestedManyWithoutAuthorInput: EntryCreateNestedManyWithoutAuthorInput;
  EntryCreateNestedManyWithoutCategoriesInput: EntryCreateNestedManyWithoutCategoriesInput;
  EntryCreateNestedOneWithoutCommentsInput: EntryCreateNestedOneWithoutCommentsInput;
  EntryCreateOrConnectWithoutAuthorInput: EntryCreateOrConnectWithoutAuthorInput;
  EntryCreateOrConnectWithoutCategoriesInput: EntryCreateOrConnectWithoutCategoriesInput;
  EntryCreateOrConnectWithoutCommentsInput: EntryCreateOrConnectWithoutCommentsInput;
  EntryCreateWithoutAuthorInput: EntryCreateWithoutAuthorInput;
  EntryCreateWithoutCategoriesInput: EntryCreateWithoutCategoriesInput;
  EntryCreateWithoutCommentsInput: EntryCreateWithoutCommentsInput;
  EntryEdge: ResolverTypeWrapper<EntryEdge>;
  EntryOrderByRelationAggregateInput: EntryOrderByRelationAggregateInput;
  EntryOrderByRelevanceFieldEnum: EntryOrderByRelevanceFieldEnum;
  EntryOrderByRelevanceInput: EntryOrderByRelevanceInput;
  EntryOrderByWithRelationAndSearchRelevanceInput: EntryOrderByWithRelationAndSearchRelevanceInput;
  EntryWhereUniqueInput: EntryWhereUniqueInput;
  EnumGenderNullableFilter: EnumGenderNullableFilter;
  EnumPronounsNullableFilter: EnumPronounsNullableFilter;
  EnumRoleNullableFilter: EnumRoleNullableFilter;
  EnumUserStatusNullableFilter: EnumUserStatusNullableFilter;
  Gender: Gender;
  ID: ResolverTypeWrapper<Scalars['ID']>;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  JSON: ResolverTypeWrapper<Scalars['JSON']>;
  JSONObject: ResolverTypeWrapper<Scalars['JSONObject']>;
  JsonNullableFilter: JsonNullableFilter;
  JwtDecoded: ResolverTypeWrapper<JwtDecoded>;
  JwtHeaders: ResolverTypeWrapper<JwtHeaders>;
  JwtPayload: ResolverTypeWrapper<JwtPayload>;
  LoginInput: LoginInput;
  ManyUsersPaginatedArgs: ManyUsersPaginatedArgs;
  Mutation: ResolverTypeWrapper<{}>;
  NestedEnumGenderNullableFilter: NestedEnumGenderNullableFilter;
  NestedEnumPronounsNullableFilter: NestedEnumPronounsNullableFilter;
  NestedEnumRoleNullableFilter: NestedEnumRoleNullableFilter;
  NestedEnumUserStatusNullableFilter: NestedEnumUserStatusNullableFilter;
  NestedStringFilter: NestedStringFilter;
  NestedStringNullableFilter: NestedStringNullableFilter;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  PaginationArgsInput: PaginationArgsInput;
  PhoneNumber: ResolverTypeWrapper<Scalars['PhoneNumber']>;
  Profile: ResolverTypeWrapper<Profile>;
  ProfileConnection: ResolverTypeWrapper<ProfileConnection>;
  ProfileCreateInput: ProfileCreateInput;
  ProfileCreateNestedOneWithoutUserInput: ProfileCreateNestedOneWithoutUserInput;
  ProfileCreateOrConnectWithoutUserInput: ProfileCreateOrConnectWithoutUserInput;
  ProfileCreateWithoutUserInput: ProfileCreateWithoutUserInput;
  ProfileCreateactiviyFeedInput: ProfileCreateactiviyFeedInput;
  ProfileCreatebioInput: ProfileCreatebioInput;
  ProfileCreaterecentActivityInput: ProfileCreaterecentActivityInput;
  ProfileEdge: ResolverTypeWrapper<ProfileEdge>;
  ProfileOrderByRelevanceFieldEnum: ProfileOrderByRelevanceFieldEnum;
  ProfileOrderByRelevanceInput: ProfileOrderByRelevanceInput;
  ProfileOrderByWithRelationAndSearchRelevanceInput: ProfileOrderByWithRelationAndSearchRelevanceInput;
  ProfileWhereUniqueInput: ProfileWhereUniqueInput;
  ProfilesInput: ProfilesInput;
  Pronouns: Pronouns;
  Query: ResolverTypeWrapper<{}>;
  QueryMode: QueryMode;
  Role: Role;
  Session: ResolverTypeWrapper<Session>;
  SessionCreateManyUserInput: SessionCreateManyUserInput;
  SessionCreateManyUserInputEnvelope: SessionCreateManyUserInputEnvelope;
  SessionCreateManyscopesInput: SessionCreateManyscopesInput;
  SessionCreateNestedManyWithoutUserInput: SessionCreateNestedManyWithoutUserInput;
  SessionCreateOrConnectWithoutUserInput: SessionCreateOrConnectWithoutUserInput;
  SessionCreateWithoutUserInput: SessionCreateWithoutUserInput;
  SessionCreatescopesInput: SessionCreatescopesInput;
  SessionOrderByRelationAggregateInput: SessionOrderByRelationAggregateInput;
  SessionWhereUniqueInput: SessionWhereUniqueInput;
  SignupInput: SignupInput;
  SortOrder: SortOrder;
  String: ResolverTypeWrapper<Scalars['String']>;
  StringFilter: StringFilter;
  StringNullableFilter: StringNullableFilter;
  Subscription: ResolverTypeWrapper<{}>;
  Token: ResolverTypeWrapper<Token>;
  User: ResolverTypeWrapper<User>;
  UserConnection: ResolverTypeWrapper<UserConnection>;
  UserCreateNestedOneWithoutCategoriesInput: UserCreateNestedOneWithoutCategoriesInput;
  UserCreateNestedOneWithoutCommentsInput: UserCreateNestedOneWithoutCommentsInput;
  UserCreateNestedOneWithoutEntriesInput: UserCreateNestedOneWithoutEntriesInput;
  UserCreateNestedOneWithoutProfileInput: UserCreateNestedOneWithoutProfileInput;
  UserCreateOrConnectWithoutCategoriesInput: UserCreateOrConnectWithoutCategoriesInput;
  UserCreateOrConnectWithoutCommentsInput: UserCreateOrConnectWithoutCommentsInput;
  UserCreateOrConnectWithoutEntriesInput: UserCreateOrConnectWithoutEntriesInput;
  UserCreateOrConnectWithoutProfileInput: UserCreateOrConnectWithoutProfileInput;
  UserCreateWithoutCategoriesInput: UserCreateWithoutCategoriesInput;
  UserCreateWithoutCommentsInput: UserCreateWithoutCommentsInput;
  UserCreateWithoutEntriesInput: UserCreateWithoutEntriesInput;
  UserCreateWithoutProfileInput: UserCreateWithoutProfileInput;
  UserEdge: ResolverTypeWrapper<UserEdge>;
  UserOrderByRelevanceFieldEnum: UserOrderByRelevanceFieldEnum;
  UserOrderByRelevanceInput: UserOrderByRelevanceInput;
  UserOrderByWithRelationAndSearchRelevanceInput: UserOrderByWithRelationAndSearchRelevanceInput;
  UserStatus: UserStatus;
  UserWhereUniqueInput: UserWhereUniqueInput;
  Viewer: ResolverTypeWrapper<Viewer>;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  Account: Account;
  AccountCreateManyUserInput: AccountCreateManyUserInput;
  AccountCreateManyUserInputEnvelope: AccountCreateManyUserInputEnvelope;
  AccountCreateNestedManyWithoutUserInput: AccountCreateNestedManyWithoutUserInput;
  AccountCreateOrConnectWithoutUserInput: AccountCreateOrConnectWithoutUserInput;
  AccountCreateWithoutUserInput: AccountCreateWithoutUserInput;
  AccountOrderByRelationAggregateInput: AccountOrderByRelationAggregateInput;
  AccountProviderProviderAccountIdCompoundUniqueInput: AccountProviderProviderAccountIdCompoundUniqueInput;
  AccountWhereUniqueInput: AccountWhereUniqueInput;
  Auth: Auth;
  AuthDetailed: AuthDetailed;
  AuthSansSession: AuthSansSession;
  BigInt: Scalars['BigInt'];
  Boolean: Scalars['Boolean'];
  Category: Category;
  CategoryCount: CategoryCount;
  CategoryCreateManyCreatorInput: CategoryCreateManyCreatorInput;
  CategoryCreateManyCreatorInputEnvelope: CategoryCreateManyCreatorInputEnvelope;
  CategoryCreateNestedManyWithoutCreatorInput: CategoryCreateNestedManyWithoutCreatorInput;
  CategoryCreateNestedManyWithoutEntriesInput: CategoryCreateNestedManyWithoutEntriesInput;
  CategoryCreateOrConnectWithoutCreatorInput: CategoryCreateOrConnectWithoutCreatorInput;
  CategoryCreateOrConnectWithoutEntriesInput: CategoryCreateOrConnectWithoutEntriesInput;
  CategoryCreateWithoutCreatorInput: CategoryCreateWithoutCreatorInput;
  CategoryCreateWithoutEntriesInput: CategoryCreateWithoutEntriesInput;
  CategoryOrderByRelationAggregateInput: CategoryOrderByRelationAggregateInput;
  CategoryWhereUniqueInput: CategoryWhereUniqueInput;
  ChangePasswordInput: ChangePasswordInput;
  Comment: Comment;
  CommentCreateManyAuthorInput: CommentCreateManyAuthorInput;
  CommentCreateManyAuthorInputEnvelope: CommentCreateManyAuthorInputEnvelope;
  CommentCreateManyEntryInput: CommentCreateManyEntryInput;
  CommentCreateManyEntryInputEnvelope: CommentCreateManyEntryInputEnvelope;
  CommentCreateManyreactionsInput: CommentCreateManyreactionsInput;
  CommentCreateNestedManyWithoutAuthorInput: CommentCreateNestedManyWithoutAuthorInput;
  CommentCreateNestedManyWithoutEntryInput: CommentCreateNestedManyWithoutEntryInput;
  CommentCreateOrConnectWithoutAuthorInput: CommentCreateOrConnectWithoutAuthorInput;
  CommentCreateOrConnectWithoutEntryInput: CommentCreateOrConnectWithoutEntryInput;
  CommentCreateWithoutAuthorInput: CommentCreateWithoutAuthorInput;
  CommentCreateWithoutEntryInput: CommentCreateWithoutEntryInput;
  CommentCreatereactionsInput: CommentCreatereactionsInput;
  CommentOrderByRelationAggregateInput: CommentOrderByRelationAggregateInput;
  CommentWhereUniqueInput: CommentWhereUniqueInput;
  Connection: Connection;
  ConnectionCreateManyOwnerInput: ConnectionCreateManyOwnerInput;
  ConnectionCreateManyOwnerInputEnvelope: ConnectionCreateManyOwnerInputEnvelope;
  ConnectionCreateNestedManyWithoutOwnerInput: ConnectionCreateNestedManyWithoutOwnerInput;
  ConnectionCreateOrConnectWithoutOwnerInput: ConnectionCreateOrConnectWithoutOwnerInput;
  ConnectionCreateWithoutOwnerInput: ConnectionCreateWithoutOwnerInput;
  ConnectionOrderByRelationAggregateInput: ConnectionOrderByRelationAggregateInput;
  ConnectionWhereUniqueInput: ConnectionWhereUniqueInput;
  DateTime: Scalars['DateTime'];
  Entry: Entry;
  EntryConnection: EntryConnection;
  EntryCount: EntryCount;
  EntryCreateInput: EntryCreateInput;
  EntryCreateManyAuthorInput: EntryCreateManyAuthorInput;
  EntryCreateManyAuthorInputEnvelope: EntryCreateManyAuthorInputEnvelope;
  EntryCreateNestedManyWithoutAuthorInput: EntryCreateNestedManyWithoutAuthorInput;
  EntryCreateNestedManyWithoutCategoriesInput: EntryCreateNestedManyWithoutCategoriesInput;
  EntryCreateNestedOneWithoutCommentsInput: EntryCreateNestedOneWithoutCommentsInput;
  EntryCreateOrConnectWithoutAuthorInput: EntryCreateOrConnectWithoutAuthorInput;
  EntryCreateOrConnectWithoutCategoriesInput: EntryCreateOrConnectWithoutCategoriesInput;
  EntryCreateOrConnectWithoutCommentsInput: EntryCreateOrConnectWithoutCommentsInput;
  EntryCreateWithoutAuthorInput: EntryCreateWithoutAuthorInput;
  EntryCreateWithoutCategoriesInput: EntryCreateWithoutCategoriesInput;
  EntryCreateWithoutCommentsInput: EntryCreateWithoutCommentsInput;
  EntryEdge: EntryEdge;
  EntryOrderByRelationAggregateInput: EntryOrderByRelationAggregateInput;
  EntryOrderByRelevanceInput: EntryOrderByRelevanceInput;
  EntryOrderByWithRelationAndSearchRelevanceInput: EntryOrderByWithRelationAndSearchRelevanceInput;
  EntryWhereUniqueInput: EntryWhereUniqueInput;
  EnumGenderNullableFilter: EnumGenderNullableFilter;
  EnumPronounsNullableFilter: EnumPronounsNullableFilter;
  EnumRoleNullableFilter: EnumRoleNullableFilter;
  EnumUserStatusNullableFilter: EnumUserStatusNullableFilter;
  ID: Scalars['ID'];
  Int: Scalars['Int'];
  JSON: Scalars['JSON'];
  JSONObject: Scalars['JSONObject'];
  JsonNullableFilter: JsonNullableFilter;
  JwtDecoded: JwtDecoded;
  JwtHeaders: JwtHeaders;
  JwtPayload: JwtPayload;
  LoginInput: LoginInput;
  ManyUsersPaginatedArgs: ManyUsersPaginatedArgs;
  Mutation: {};
  NestedEnumGenderNullableFilter: NestedEnumGenderNullableFilter;
  NestedEnumPronounsNullableFilter: NestedEnumPronounsNullableFilter;
  NestedEnumRoleNullableFilter: NestedEnumRoleNullableFilter;
  NestedEnumUserStatusNullableFilter: NestedEnumUserStatusNullableFilter;
  NestedStringFilter: NestedStringFilter;
  NestedStringNullableFilter: NestedStringNullableFilter;
  PageInfo: PageInfo;
  PaginationArgsInput: PaginationArgsInput;
  PhoneNumber: Scalars['PhoneNumber'];
  Profile: Profile;
  ProfileConnection: ProfileConnection;
  ProfileCreateInput: ProfileCreateInput;
  ProfileCreateNestedOneWithoutUserInput: ProfileCreateNestedOneWithoutUserInput;
  ProfileCreateOrConnectWithoutUserInput: ProfileCreateOrConnectWithoutUserInput;
  ProfileCreateWithoutUserInput: ProfileCreateWithoutUserInput;
  ProfileCreateactiviyFeedInput: ProfileCreateactiviyFeedInput;
  ProfileCreatebioInput: ProfileCreatebioInput;
  ProfileCreaterecentActivityInput: ProfileCreaterecentActivityInput;
  ProfileEdge: ProfileEdge;
  ProfileOrderByRelevanceInput: ProfileOrderByRelevanceInput;
  ProfileOrderByWithRelationAndSearchRelevanceInput: ProfileOrderByWithRelationAndSearchRelevanceInput;
  ProfileWhereUniqueInput: ProfileWhereUniqueInput;
  ProfilesInput: ProfilesInput;
  Query: {};
  Session: Session;
  SessionCreateManyUserInput: SessionCreateManyUserInput;
  SessionCreateManyUserInputEnvelope: SessionCreateManyUserInputEnvelope;
  SessionCreateManyscopesInput: SessionCreateManyscopesInput;
  SessionCreateNestedManyWithoutUserInput: SessionCreateNestedManyWithoutUserInput;
  SessionCreateOrConnectWithoutUserInput: SessionCreateOrConnectWithoutUserInput;
  SessionCreateWithoutUserInput: SessionCreateWithoutUserInput;
  SessionCreatescopesInput: SessionCreatescopesInput;
  SessionOrderByRelationAggregateInput: SessionOrderByRelationAggregateInput;
  SessionWhereUniqueInput: SessionWhereUniqueInput;
  SignupInput: SignupInput;
  String: Scalars['String'];
  StringFilter: StringFilter;
  StringNullableFilter: StringNullableFilter;
  Subscription: {};
  Token: Token;
  User: User;
  UserConnection: UserConnection;
  UserCreateNestedOneWithoutCategoriesInput: UserCreateNestedOneWithoutCategoriesInput;
  UserCreateNestedOneWithoutCommentsInput: UserCreateNestedOneWithoutCommentsInput;
  UserCreateNestedOneWithoutEntriesInput: UserCreateNestedOneWithoutEntriesInput;
  UserCreateNestedOneWithoutProfileInput: UserCreateNestedOneWithoutProfileInput;
  UserCreateOrConnectWithoutCategoriesInput: UserCreateOrConnectWithoutCategoriesInput;
  UserCreateOrConnectWithoutCommentsInput: UserCreateOrConnectWithoutCommentsInput;
  UserCreateOrConnectWithoutEntriesInput: UserCreateOrConnectWithoutEntriesInput;
  UserCreateOrConnectWithoutProfileInput: UserCreateOrConnectWithoutProfileInput;
  UserCreateWithoutCategoriesInput: UserCreateWithoutCategoriesInput;
  UserCreateWithoutCommentsInput: UserCreateWithoutCommentsInput;
  UserCreateWithoutEntriesInput: UserCreateWithoutEntriesInput;
  UserCreateWithoutProfileInput: UserCreateWithoutProfileInput;
  UserEdge: UserEdge;
  UserOrderByRelevanceInput: UserOrderByRelevanceInput;
  UserOrderByWithRelationAndSearchRelevanceInput: UserOrderByWithRelationAndSearchRelevanceInput;
  UserWhereUniqueInput: UserWhereUniqueInput;
  Viewer: Viewer;
}>;

export type AccountResolvers<ContextType = any, ParentType extends ResolversParentTypes['Account'] = ResolversParentTypes['Account']> = ResolversObject<{
  access_token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expires_at?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id_token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauth_token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauth_token_secret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  provider?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  providerAccountId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  refresh_secret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  refresh_token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  scope?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  session_state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  token_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthResolvers<ContextType = any, ParentType extends ResolversParentTypes['Auth'] = ResolversParentTypes['Auth']> = ResolversObject<{
  accessToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  refreshToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  session?: Resolver<Maybe<ResolversTypes['Session']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthDetailedResolvers<ContextType = any, ParentType extends ResolversParentTypes['AuthDetailed'] = ResolversParentTypes['AuthDetailed']> = ResolversObject<{
  auth?: Resolver<Maybe<ResolversTypes['Auth']>, ParentType, ContextType>;
  jwt?: Resolver<Maybe<ResolversTypes['JwtDecoded']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthSansSessionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AuthSansSession'] = ResolversParentTypes['AuthSansSession']> = ResolversObject<{
  accessToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  refreshToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
  name: 'BigInt';
}

export type CategoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Category'] = ResolversParentTypes['Category']> = ResolversObject<{
  _count?: Resolver<ResolversTypes['CategoryCount'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  creator?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  creatorId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  entries?: Resolver<Maybe<Array<ResolversTypes['Entry']>>, ParentType, ContextType>;
  entryId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CategoryCountResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryCount'] = ResolversParentTypes['CategoryCount']> = ResolversObject<{
  entries?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommentResolvers<ContextType = any, ParentType extends ResolversParentTypes['Comment'] = ResolversParentTypes['Comment']> = ResolversObject<{
  author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  authorId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  body?: Resolver<Maybe<ResolversTypes['JSONObject']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  entry?: Resolver<ResolversTypes['Entry'], ParentType, ContextType>;
  entryId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reactions?: Resolver<Maybe<Array<ResolversTypes['CommentReactions']>>, ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Connection'] = ResolversParentTypes['Connection']> = ResolversObject<{
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ip?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  ownerId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  phoneNumber?: Resolver<Maybe<ResolversTypes['PhoneNumber']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
  name: 'DateTime';
}

export type EntryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Entry'] = ResolversParentTypes['Entry']> = ResolversObject<{
  _count?: Resolver<ResolversTypes['EntryCount'], ParentType, ContextType>;
  author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  authorId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  categories?: Resolver<Maybe<Array<ResolversTypes['Category']>>, ParentType, ContextType>;
  categoryId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comments?: Resolver<Maybe<Array<ResolversTypes['Comment']>>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  featuredImage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  published?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EntryConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntryConnection'] = ResolversParentTypes['EntryConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['EntryEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EntryCountResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntryCount'] = ResolversParentTypes['EntryCount']> = ResolversObject<{
  categories?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EntryEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntryEdge'] = ResolversParentTypes['EntryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Entry'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
  name: 'JSON';
}

export interface JsonObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSONObject'], any> {
  name: 'JSONObject';
}

export type JwtDecodedResolvers<ContextType = any, ParentType extends ResolversParentTypes['JwtDecoded'] = ResolversParentTypes['JwtDecoded']> = ResolversObject<{
  header?: Resolver<ResolversTypes['JwtHeaders'], ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['JwtPayload'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type JwtHeadersResolvers<ContextType = any, ParentType extends ResolversParentTypes['JwtHeaders'] = ResolversParentTypes['JwtHeaders']> = ResolversObject<{
  alg?: Resolver<ResolversTypes['AlgorithmType'], ParentType, ContextType>;
  typ?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type JwtPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['JwtPayload'] = ResolversParentTypes['JwtPayload']> = ResolversObject<{
  exp?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  iat?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = ResolversObject<{
  changePassword?: Resolver<ResolversTypes['User'], ParentType, ContextType, RequireFields<MutationChangePasswordArgs, 'accessToken' | 'data'>>;
  createEntry?: Resolver<ResolversTypes['Entry'], ParentType, ContextType, RequireFields<MutationCreateEntryArgs, 'data'>>;
  createProfile?: Resolver<ResolversTypes['Profile'], ParentType, ContextType, RequireFields<MutationCreateProfileArgs, 'data' | 'userId'>>;
  getUserFromAccessToken?: Resolver<ResolversTypes['User'], ParentType, ContextType, RequireFields<MutationGetUserFromAccessTokenArgs, 'token'>>;
  login?: Resolver<ResolversTypes['Token'], ParentType, ContextType, RequireFields<MutationLoginArgs, 'data'>>;
  refreshToken?: Resolver<ResolversTypes['Token'], ParentType, ContextType, RequireFields<MutationRefreshTokenArgs, 'token'>>;
  register?: Resolver<ResolversTypes['AuthSansSession'], ParentType, ContextType, RequireFields<MutationRegisterArgs, 'dataRegister'>>;
  signin?: Resolver<ResolversTypes['AuthDetailed'], ParentType, ContextType>;
  signup?: Resolver<ResolversTypes['Token'], ParentType, ContextType, RequireFields<MutationSignupArgs, 'data'>>;
}>;

export type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = ResolversObject<{
  endCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface PhoneNumberScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['PhoneNumber'], any> {
  name: 'PhoneNumber';
}

export type ProfileResolvers<ContextType = any, ParentType extends ResolversParentTypes['Profile'] = ResolversParentTypes['Profile']> = ResolversObject<{
  activiyFeed?: Resolver<Maybe<Array<ResolversTypes['JSON']>>, ParentType, ContextType>;
  bio?: Resolver<Maybe<Array<ResolversTypes['JSON']>>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  coverPhoto?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dob?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gender?: Resolver<Maybe<ResolversTypes['Gender']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastSeen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  memberSince?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  occupation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  phoneNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pronouns?: Resolver<Maybe<ResolversTypes['Pronouns']>, ParentType, ContextType>;
  recentActivity?: Resolver<Maybe<Array<ResolversTypes['JSON']>>, ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  userInProfile?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProfileConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProfileConnection'] = ResolversParentTypes['ProfileConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ProfileEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProfileEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProfileEdge'] = ResolversParentTypes['ProfileEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Profile'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = ResolversObject<{
  entryById?: Resolver<ResolversTypes['Entry'], ParentType, ContextType, RequireFields<QueryEntryByIdArgs, 'id'>>;
  entryCursorConnection?: Resolver<ResolversTypes['EntryConnection'], ParentType, ContextType, RequireFields<QueryEntryCursorConnectionArgs, 'first'>>;
  getProfiles?: Resolver<ResolversTypes['ProfileConnection'], ParentType, ContextType, RequireFields<QueryGetProfilesArgs, 'first'>>;
  getViewer?: Resolver<ResolversTypes['Viewer'], ParentType, ContextType, RequireFields<QueryGetViewerArgs, 'id'>>;
  hello?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<QueryHelloArgs, 'name'>>;
  helloWorld?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  listUsers?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, Partial<QueryListUsersArgs>>;
  me?: Resolver<ResolversTypes['AuthDetailed'], ParentType, ContextType>;
  profileByRelayId?: Resolver<ResolversTypes['Profile'], ParentType, ContextType>;
  profiles?: Resolver<ResolversTypes['ProfileConnection'], ParentType, ContextType, RequireFields<QueryProfilesArgs, 'profilesArgs'>>;
  userById?: Resolver<ResolversTypes['User'], ParentType, ContextType, RequireFields<QueryUserByIdArgs, 'id'>>;
  userByRelayId?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  userPosts?: Resolver<Array<ResolversTypes['Entry']>, ParentType, ContextType, RequireFields<QueryUserPostsArgs, 'userId'>>;
}>;

export type SessionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Session'] = ResolversParentTypes['Session']> = ResolversObject<{
  accessToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  alg?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  exp?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  iat?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastVerified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  provider?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  refreshToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  scopes?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  signature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tokenState?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = ResolversObject<{
  entryCreated?: SubscriptionResolver<ResolversTypes['Entry'], "entryCreated", ParentType, ContextType>;
  profileCreated?: SubscriptionResolver<ResolversTypes['Profile'], "profileCreated", ParentType, ContextType>;
}>;

export type TokenResolvers<ContextType = any, ParentType extends ResolversParentTypes['Token'] = ResolversParentTypes['Token']> = ResolversObject<{
  accessToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  refreshToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = ResolversObject<{
  accounts?: Resolver<Maybe<Array<ResolversTypes['Account']>>, ParentType, ContextType>;
  categories?: Resolver<Maybe<Array<ResolversTypes['Category']>>, ParentType, ContextType>;
  comments?: Resolver<Maybe<Array<ResolversTypes['Comment']>>, ParentType, ContextType>;
  connections?: Resolver<Maybe<Array<ResolversTypes['Connection']>>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  emailVerified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  entries?: Resolver<Maybe<Array<ResolversTypes['Entry']>>, ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  password?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  profile?: Resolver<Maybe<ResolversTypes['Profile']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType>;
  sessions?: Resolver<Maybe<Array<ResolversTypes['Session']>>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['UserStatus'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserConnection'] = ResolversParentTypes['UserConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['UserEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserEdge'] = ResolversParentTypes['UserEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ViewerResolvers<ContextType = any, ParentType extends ResolversParentTypes['Viewer'] = ResolversParentTypes['Viewer']> = ResolversObject<{
  accessToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  accounts?: Resolver<Maybe<Array<ResolversTypes['Account']>>, ParentType, ContextType>;
  categories?: Resolver<Maybe<Array<ResolversTypes['Category']>>, ParentType, ContextType>;
  comments?: Resolver<Maybe<Array<ResolversTypes['Comment']>>, ParentType, ContextType>;
  connections?: Resolver<Maybe<Array<ResolversTypes['Connection']>>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  emailVerified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  entries?: Resolver<Maybe<Array<ResolversTypes['Entry']>>, ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  password?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  profile?: Resolver<Maybe<ResolversTypes['Profile']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType>;
  sessions?: Resolver<Maybe<Array<ResolversTypes['Session']>>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['UserStatus'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Resolvers<ContextType = any> = ResolversObject<{
  Account?: AccountResolvers<ContextType>;
  Auth?: AuthResolvers<ContextType>;
  AuthDetailed?: AuthDetailedResolvers<ContextType>;
  AuthSansSession?: AuthSansSessionResolvers<ContextType>;
  BigInt?: GraphQLScalarType;
  Category?: CategoryResolvers<ContextType>;
  CategoryCount?: CategoryCountResolvers<ContextType>;
  Comment?: CommentResolvers<ContextType>;
  Connection?: ConnectionResolvers<ContextType>;
  DateTime?: GraphQLScalarType;
  Entry?: EntryResolvers<ContextType>;
  EntryConnection?: EntryConnectionResolvers<ContextType>;
  EntryCount?: EntryCountResolvers<ContextType>;
  EntryEdge?: EntryEdgeResolvers<ContextType>;
  JSON?: GraphQLScalarType;
  JSONObject?: GraphQLScalarType;
  JwtDecoded?: JwtDecodedResolvers<ContextType>;
  JwtHeaders?: JwtHeadersResolvers<ContextType>;
  JwtPayload?: JwtPayloadResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  PhoneNumber?: GraphQLScalarType;
  Profile?: ProfileResolvers<ContextType>;
  ProfileConnection?: ProfileConnectionResolvers<ContextType>;
  ProfileEdge?: ProfileEdgeResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  Session?: SessionResolvers<ContextType>;
  Subscription?: SubscriptionResolvers<ContextType>;
  Token?: TokenResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserConnection?: UserConnectionResolvers<ContextType>;
  UserEdge?: UserEdgeResolvers<ContextType>;
  Viewer?: ViewerResolvers<ContextType>;
}>;

