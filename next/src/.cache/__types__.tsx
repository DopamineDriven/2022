/* 713d0dd2a9c7eca0c4703d9a6982e5e12e7c592d
 * This file is automatically generated by graphql-let. */

import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** The `BigInt` scalar type represents non-fractional signed whole numeric values. */
  BigInt: any;
  /** A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format. */
  DateTime: any;
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: any;
  /** The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSONObject: any;
  /** A field whose value conforms to the standard E.164 format as specified in: https://en.wikipedia.org/wiki/E.164. Basically this is +17895551234. */
  PhoneNumber: any;
};

export type Account = {
  __typename?: 'Account';
  access_token?: Maybe<Scalars['String']>;
  expires_at?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  id_token?: Maybe<Scalars['String']>;
  oauth_token?: Maybe<Scalars['String']>;
  oauth_token_secret?: Maybe<Scalars['String']>;
  provider: Scalars['String'];
  providerAccountId: Scalars['String'];
  refresh_secret?: Maybe<Scalars['String']>;
  refresh_token?: Maybe<Scalars['String']>;
  scope?: Maybe<Scalars['String']>;
  session_state?: Maybe<Scalars['String']>;
  token_type?: Maybe<Scalars['String']>;
  type: Scalars['String'];
  user: User;
  userId: Scalars['String'];
};

export type AccountCreateManyUserInput = {
  access_token?: InputMaybe<Scalars['String']>;
  expires_at?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  id_token?: InputMaybe<Scalars['String']>;
  oauth_token?: InputMaybe<Scalars['String']>;
  oauth_token_secret?: InputMaybe<Scalars['String']>;
  provider: Scalars['String'];
  providerAccountId: Scalars['String'];
  refresh_secret?: InputMaybe<Scalars['String']>;
  refresh_token?: InputMaybe<Scalars['String']>;
  scope?: InputMaybe<Scalars['String']>;
  session_state?: InputMaybe<Scalars['String']>;
  token_type?: InputMaybe<Scalars['String']>;
  type: Scalars['String'];
};

export type AccountCreateManyUserInputEnvelope = {
  data: Array<AccountCreateManyUserInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type AccountCreateNestedManyWithoutUserInput = {
  connect?: InputMaybe<Array<AccountWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<AccountCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<AccountCreateWithoutUserInput>>;
  createMany?: InputMaybe<AccountCreateManyUserInputEnvelope>;
};

export type AccountCreateOrConnectWithoutUserInput = {
  create: AccountCreateWithoutUserInput;
  where: AccountWhereUniqueInput;
};

export type AccountCreateWithoutUserInput = {
  access_token?: InputMaybe<Scalars['String']>;
  expires_at?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  id_token?: InputMaybe<Scalars['String']>;
  oauth_token?: InputMaybe<Scalars['String']>;
  oauth_token_secret?: InputMaybe<Scalars['String']>;
  provider: Scalars['String'];
  providerAccountId: Scalars['String'];
  refresh_secret?: InputMaybe<Scalars['String']>;
  refresh_token?: InputMaybe<Scalars['String']>;
  scope?: InputMaybe<Scalars['String']>;
  session_state?: InputMaybe<Scalars['String']>;
  token_type?: InputMaybe<Scalars['String']>;
  type: Scalars['String'];
};

export type AccountListRelationFilter = {
  every?: InputMaybe<AccountWhereInput>;
  none?: InputMaybe<AccountWhereInput>;
  some?: InputMaybe<AccountWhereInput>;
};

export type AccountOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type AccountProviderProviderAccountIdCompoundUniqueInput = {
  provider: Scalars['String'];
  providerAccountId: Scalars['String'];
};

export type AccountWhereInput = {
  AND?: InputMaybe<Array<AccountWhereInput>>;
  NOT?: InputMaybe<Array<AccountWhereInput>>;
  OR?: InputMaybe<Array<AccountWhereInput>>;
  access_token?: InputMaybe<StringNullableFilter>;
  expires_at?: InputMaybe<IntNullableFilter>;
  id?: InputMaybe<StringFilter>;
  id_token?: InputMaybe<StringNullableFilter>;
  oauth_token?: InputMaybe<StringNullableFilter>;
  oauth_token_secret?: InputMaybe<StringNullableFilter>;
  provider?: InputMaybe<StringFilter>;
  providerAccountId?: InputMaybe<StringFilter>;
  refresh_secret?: InputMaybe<StringNullableFilter>;
  refresh_token?: InputMaybe<StringNullableFilter>;
  scope?: InputMaybe<StringNullableFilter>;
  session_state?: InputMaybe<StringNullableFilter>;
  token_type?: InputMaybe<StringNullableFilter>;
  type?: InputMaybe<StringFilter>;
  user?: InputMaybe<UserRelationFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type AccountWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
  provider_providerAccountId?: InputMaybe<AccountProviderProviderAccountIdCompoundUniqueInput>;
};

export enum AlgorithmType {
  Es256 = 'ES256',
  Es256K = 'ES256K',
  Es384 = 'ES384',
  Es512 = 'ES512',
  Ed448 = 'Ed448',
  Ed25519 = 'Ed25519',
  Hs256 = 'HS256',
  Hs384 = 'HS384',
  Hs512 = 'HS512',
  None = 'None',
  Ps256 = 'PS256',
  Ps384 = 'PS384',
  Ps512 = 'PS512',
  Rs256 = 'RS256',
  Rs384 = 'RS384',
  Rs512 = 'RS512'
}

export type Auth = {
  __typename?: 'Auth';
  accessToken?: Maybe<Scalars['String']>;
  refreshToken?: Maybe<Scalars['String']>;
  session?: Maybe<Session>;
  user: User;
};

export type AuthDetailed = {
  __typename?: 'AuthDetailed';
  auth?: Maybe<Auth>;
  jwt?: Maybe<JwtDecoded>;
};

export type AuthSansSession = {
  __typename?: 'AuthSansSession';
  accessToken?: Maybe<Scalars['String']>;
  refreshToken?: Maybe<Scalars['String']>;
  user?: Maybe<User>;
};

export type BaseTypeNodes = {
  __typename?: 'BaseTypeNodes';
  nodes: Array<TypesUnion>;
  pageInfo?: Maybe<PageInfo>;
  totalCount: Scalars['Int'];
};

export type BaseTypesEdge = {
  __typename?: 'BaseTypesEdge';
  cursor: Scalars['String'];
  node: TypesUnion;
};

export type BoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolFilter>;
};

export type Category = {
  __typename?: 'Category';
  _count: CategoryCount;
  createdAt?: Maybe<Scalars['DateTime']>;
  creator: User;
  creatorId: Scalars['String'];
  entries?: Maybe<Array<Entry>>;
  entryId?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CategoryCount = {
  __typename?: 'CategoryCount';
  entries: Scalars['Int'];
};

export type CategoryCreateManyCreatorInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  entryId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CategoryCreateManyCreatorInputEnvelope = {
  data: Array<CategoryCreateManyCreatorInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type CategoryCreateNestedManyWithoutCreatorInput = {
  connect?: InputMaybe<Array<CategoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CategoryCreateOrConnectWithoutCreatorInput>>;
  create?: InputMaybe<Array<CategoryCreateWithoutCreatorInput>>;
  createMany?: InputMaybe<CategoryCreateManyCreatorInputEnvelope>;
};

export type CategoryCreateNestedManyWithoutEntriesInput = {
  connect?: InputMaybe<Array<CategoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CategoryCreateOrConnectWithoutEntriesInput>>;
  create?: InputMaybe<Array<CategoryCreateWithoutEntriesInput>>;
};

export type CategoryCreateOrConnectWithoutCreatorInput = {
  create: CategoryCreateWithoutCreatorInput;
  where: CategoryWhereUniqueInput;
};

export type CategoryCreateOrConnectWithoutEntriesInput = {
  create: CategoryCreateWithoutEntriesInput;
  where: CategoryWhereUniqueInput;
};

export type CategoryCreateWithoutCreatorInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  entries?: InputMaybe<EntryCreateNestedManyWithoutCategoriesInput>;
  entryId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CategoryCreateWithoutEntriesInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  creator: UserCreateNestedOneWithoutCategoriesInput;
  entryId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CategoryListRelationFilter = {
  every?: InputMaybe<CategoryWhereInput>;
  none?: InputMaybe<CategoryWhereInput>;
  some?: InputMaybe<CategoryWhereInput>;
};

export type CategoryOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type CategoryWhereInput = {
  AND?: InputMaybe<Array<CategoryWhereInput>>;
  NOT?: InputMaybe<Array<CategoryWhereInput>>;
  OR?: InputMaybe<Array<CategoryWhereInput>>;
  createdAt?: InputMaybe<DateTimeNullableFilter>;
  creator?: InputMaybe<UserRelationFilter>;
  creatorId?: InputMaybe<StringFilter>;
  entries?: InputMaybe<EntryListRelationFilter>;
  entryId?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeNullableFilter>;
};

export type CategoryWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};

export type ChangePasswordInput = {
  newPassword: Scalars['String'];
  oldPassword: Scalars['String'];
};

export type Comment = {
  __typename?: 'Comment';
  author: User;
  authorId: Scalars['String'];
  body?: Maybe<Scalars['JSONObject']>;
  createdAt: Scalars['DateTime'];
  entry: Entry;
  entryId: Scalars['String'];
  id: Scalars['ID'];
  position?: Maybe<Scalars['String']>;
  reactions?: Maybe<Array<CommentReactions>>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CommentAuthorIdEntryIdCompoundUniqueInput = {
  authorId: Scalars['String'];
  entryId: Scalars['String'];
};

export type CommentCreateManyAuthorInput = {
  body?: InputMaybe<Scalars['JSON']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  entryId: Scalars['String'];
  id?: InputMaybe<Scalars['String']>;
  position?: InputMaybe<Scalars['String']>;
  reactions?: InputMaybe<CommentCreateManyreactionsInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CommentCreateManyAuthorInputEnvelope = {
  data: Array<CommentCreateManyAuthorInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type CommentCreateManyEntryInput = {
  authorId: Scalars['String'];
  body?: InputMaybe<Scalars['JSON']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['String']>;
  position?: InputMaybe<Scalars['String']>;
  reactions?: InputMaybe<CommentCreateManyreactionsInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CommentCreateManyEntryInputEnvelope = {
  data: Array<CommentCreateManyEntryInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type CommentCreateManyreactionsInput = {
  set: Array<CommentReactions>;
};

export type CommentCreateNestedManyWithoutAuthorInput = {
  connect?: InputMaybe<Array<CommentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CommentCreateOrConnectWithoutAuthorInput>>;
  create?: InputMaybe<Array<CommentCreateWithoutAuthorInput>>;
  createMany?: InputMaybe<CommentCreateManyAuthorInputEnvelope>;
};

export type CommentCreateNestedManyWithoutEntryInput = {
  connect?: InputMaybe<Array<CommentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CommentCreateOrConnectWithoutEntryInput>>;
  create?: InputMaybe<Array<CommentCreateWithoutEntryInput>>;
  createMany?: InputMaybe<CommentCreateManyEntryInputEnvelope>;
};

export type CommentCreateOrConnectWithoutAuthorInput = {
  create: CommentCreateWithoutAuthorInput;
  where: CommentWhereUniqueInput;
};

export type CommentCreateOrConnectWithoutEntryInput = {
  create: CommentCreateWithoutEntryInput;
  where: CommentWhereUniqueInput;
};

export type CommentCreateWithoutAuthorInput = {
  body?: InputMaybe<Scalars['JSON']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  entry: EntryCreateNestedOneWithoutCommentsInput;
  id?: InputMaybe<Scalars['String']>;
  position?: InputMaybe<Scalars['String']>;
  reactions?: InputMaybe<CommentCreatereactionsInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CommentCreateWithoutEntryInput = {
  author: UserCreateNestedOneWithoutCommentsInput;
  body?: InputMaybe<Scalars['JSON']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['String']>;
  position?: InputMaybe<Scalars['String']>;
  reactions?: InputMaybe<CommentCreatereactionsInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CommentCreatereactionsInput = {
  set: Array<CommentReactions>;
};

export type CommentListRelationFilter = {
  every?: InputMaybe<CommentWhereInput>;
  none?: InputMaybe<CommentWhereInput>;
  some?: InputMaybe<CommentWhereInput>;
};

export type CommentOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum CommentReactions {
  Angry = 'ANGRY',
  Care = 'CARE',
  Confused = 'CONFUSED',
  Dislike = 'DISLIKE',
  Laugh = 'LAUGH',
  Like = 'LIKE',
  Love = 'LOVE',
  Parrot = 'PARROT',
  Rocket = 'ROCKET',
  Tears = 'TEARS',
  Wow = 'WOW'
}

export type CommentWhereInput = {
  AND?: InputMaybe<Array<CommentWhereInput>>;
  NOT?: InputMaybe<Array<CommentWhereInput>>;
  OR?: InputMaybe<Array<CommentWhereInput>>;
  author?: InputMaybe<UserRelationFilter>;
  authorId?: InputMaybe<StringFilter>;
  body?: InputMaybe<JsonNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  entry?: InputMaybe<EntryRelationFilter>;
  entryId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  position?: InputMaybe<StringNullableFilter>;
  reactions?: InputMaybe<EnumCommentReactionsNullableListFilter>;
  updatedAt?: InputMaybe<DateTimeNullableFilter>;
};

export type CommentWhereUniqueInput = {
  authorId_entryId?: InputMaybe<CommentAuthorIdEntryIdCompoundUniqueInput>;
  id?: InputMaybe<Scalars['String']>;
};

export type Connection = {
  __typename?: 'Connection';
  email: Scalars['String'];
  firstName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  ip?: Maybe<Scalars['String']>;
  lastModified?: Maybe<Scalars['DateTime']>;
  lastName?: Maybe<Scalars['String']>;
  owner: User;
  ownerId: Scalars['String'];
  phoneNumber?: Maybe<Scalars['PhoneNumber']>;
};

export type ConnectionCreateManyOwnerInput = {
  email: Scalars['String'];
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  ip?: InputMaybe<Scalars['String']>;
  lastModified?: InputMaybe<Scalars['DateTime']>;
  lastName?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
};

export type ConnectionCreateManyOwnerInputEnvelope = {
  data: Array<ConnectionCreateManyOwnerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type ConnectionCreateNestedManyWithoutOwnerInput = {
  connect?: InputMaybe<Array<ConnectionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConnectionCreateOrConnectWithoutOwnerInput>>;
  create?: InputMaybe<Array<ConnectionCreateWithoutOwnerInput>>;
  createMany?: InputMaybe<ConnectionCreateManyOwnerInputEnvelope>;
};

export type ConnectionCreateOrConnectWithoutOwnerInput = {
  create: ConnectionCreateWithoutOwnerInput;
  where: ConnectionWhereUniqueInput;
};

export type ConnectionCreateWithoutOwnerInput = {
  email: Scalars['String'];
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  ip?: InputMaybe<Scalars['String']>;
  lastModified?: InputMaybe<Scalars['DateTime']>;
  lastName?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
};

export type ConnectionListRelationFilter = {
  every?: InputMaybe<ConnectionWhereInput>;
  none?: InputMaybe<ConnectionWhereInput>;
  some?: InputMaybe<ConnectionWhereInput>;
};

export type ConnectionOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ConnectionWhereInput = {
  AND?: InputMaybe<Array<ConnectionWhereInput>>;
  NOT?: InputMaybe<Array<ConnectionWhereInput>>;
  OR?: InputMaybe<Array<ConnectionWhereInput>>;
  email?: InputMaybe<StringFilter>;
  firstName?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<StringFilter>;
  ip?: InputMaybe<StringNullableFilter>;
  lastModified?: InputMaybe<DateTimeNullableFilter>;
  lastName?: InputMaybe<StringNullableFilter>;
  owner?: InputMaybe<UserRelationFilter>;
  ownerId?: InputMaybe<StringFilter>;
  phoneNumber?: InputMaybe<StringNullableFilter>;
};

export type ConnectionWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
};

export type ContentNodes = {
  __typename?: 'ContentNodes';
  contentNodes: BaseTypeNodes;
};

export type DateTimeFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type DateTimeNullableFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type Entry = {
  __typename?: 'Entry';
  _count: EntryCount;
  author: User;
  authorId: Scalars['String'];
  categories?: Maybe<Array<Category>>;
  categoryId?: Maybe<Scalars['String']>;
  comments?: Maybe<Array<Comment>>;
  content?: Maybe<Array<Scalars['JSONObject']>>;
  createdAt: Scalars['DateTime'];
  featuredImage?: Maybe<Array<Scalars['JSONObject']>>;
  id: Scalars['ID'];
  published?: Maybe<Scalars['Boolean']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type EntryConnection = {
  __typename?: 'EntryConnection';
  edges: Array<EntryEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type EntryCount = {
  __typename?: 'EntryCount';
  categories: Scalars['Int'];
  comments: Scalars['Int'];
};

export type EntryCreateInput = {
  author: UserCreateNestedOneWithoutEntriesInput;
  categories?: InputMaybe<CategoryCreateNestedManyWithoutEntriesInput>;
  categoryId?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<CommentCreateNestedManyWithoutEntryInput>;
  content?: InputMaybe<EntryCreatecontentInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  featuredImage?: InputMaybe<EntryCreatefeaturedImageInput>;
  id?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Boolean']>;
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type EntryCreateManyAuthorInput = {
  categoryId?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<EntryCreateManycontentInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  featuredImage?: InputMaybe<EntryCreateManyfeaturedImageInput>;
  id?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Boolean']>;
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type EntryCreateManyAuthorInputEnvelope = {
  data: Array<EntryCreateManyAuthorInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type EntryCreateManycontentInput = {
  set: Array<Scalars['JSON']>;
};

export type EntryCreateManyfeaturedImageInput = {
  set: Array<Scalars['JSON']>;
};

export type EntryCreateNestedManyWithoutAuthorInput = {
  connect?: InputMaybe<Array<EntryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EntryCreateOrConnectWithoutAuthorInput>>;
  create?: InputMaybe<Array<EntryCreateWithoutAuthorInput>>;
  createMany?: InputMaybe<EntryCreateManyAuthorInputEnvelope>;
};

export type EntryCreateNestedManyWithoutCategoriesInput = {
  connect?: InputMaybe<Array<EntryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EntryCreateOrConnectWithoutCategoriesInput>>;
  create?: InputMaybe<Array<EntryCreateWithoutCategoriesInput>>;
};

export type EntryCreateNestedOneWithoutCommentsInput = {
  connect?: InputMaybe<EntryWhereUniqueInput>;
  connectOrCreate?: InputMaybe<EntryCreateOrConnectWithoutCommentsInput>;
  create?: InputMaybe<EntryCreateWithoutCommentsInput>;
};

export type EntryCreateOrConnectWithoutAuthorInput = {
  create: EntryCreateWithoutAuthorInput;
  where: EntryWhereUniqueInput;
};

export type EntryCreateOrConnectWithoutCategoriesInput = {
  create: EntryCreateWithoutCategoriesInput;
  where: EntryWhereUniqueInput;
};

export type EntryCreateOrConnectWithoutCommentsInput = {
  create: EntryCreateWithoutCommentsInput;
  where: EntryWhereUniqueInput;
};

export type EntryCreateWithoutAuthorInput = {
  categories?: InputMaybe<CategoryCreateNestedManyWithoutEntriesInput>;
  categoryId?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<CommentCreateNestedManyWithoutEntryInput>;
  content?: InputMaybe<EntryCreatecontentInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  featuredImage?: InputMaybe<EntryCreatefeaturedImageInput>;
  id?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Boolean']>;
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type EntryCreateWithoutCategoriesInput = {
  author: UserCreateNestedOneWithoutEntriesInput;
  categoryId?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<CommentCreateNestedManyWithoutEntryInput>;
  content?: InputMaybe<EntryCreatecontentInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  featuredImage?: InputMaybe<EntryCreatefeaturedImageInput>;
  id?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Boolean']>;
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type EntryCreateWithoutCommentsInput = {
  author: UserCreateNestedOneWithoutEntriesInput;
  categories?: InputMaybe<CategoryCreateNestedManyWithoutEntriesInput>;
  categoryId?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<EntryCreatecontentInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  featuredImage?: InputMaybe<EntryCreatefeaturedImageInput>;
  id?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Boolean']>;
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type EntryCreatecontentInput = {
  set: Array<Scalars['JSON']>;
};

export type EntryCreatefeaturedImageInput = {
  set: Array<Scalars['JSON']>;
};

export type EntryEdge = {
  __typename?: 'EntryEdge';
  cursor: Scalars['String'];
  node: Entry;
};

export type EntryListRelationFilter = {
  every?: InputMaybe<EntryWhereInput>;
  none?: InputMaybe<EntryWhereInput>;
  some?: InputMaybe<EntryWhereInput>;
};

export type EntryOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EntryOrderByRelevanceFieldEnum {
  AuthorId = 'authorId',
  CategoryId = 'categoryId',
  Id = 'id',
  Title = 'title'
}

export type EntryOrderByRelevanceInput = {
  fields: Array<EntryOrderByRelevanceFieldEnum>;
  search: Scalars['String'];
  sort: SortOrder;
};

export type EntryOrderByWithRelationAndSearchRelevanceInput = {
  _relevance?: InputMaybe<EntryOrderByRelevanceInput>;
  author?: InputMaybe<UserOrderByWithRelationAndSearchRelevanceInput>;
  authorId?: InputMaybe<SortOrder>;
  categories?: InputMaybe<CategoryOrderByRelationAggregateInput>;
  categoryId?: InputMaybe<SortOrder>;
  comments?: InputMaybe<CommentOrderByRelationAggregateInput>;
  content?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  featuredImage?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  published?: InputMaybe<SortOrder>;
  title?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type EntryRelationFilter = {
  is?: InputMaybe<EntryWhereInput>;
  isNot?: InputMaybe<EntryWhereInput>;
};

export enum EntryScalarFieldEnum {
  AuthorId = 'authorId',
  CategoryId = 'categoryId',
  Content = 'content',
  CreatedAt = 'createdAt',
  FeaturedImage = 'featuredImage',
  Id = 'id',
  Published = 'published',
  Title = 'title',
  UpdatedAt = 'updatedAt'
}

export type EntryWhereInput = {
  AND?: InputMaybe<Array<EntryWhereInput>>;
  NOT?: InputMaybe<Array<EntryWhereInput>>;
  OR?: InputMaybe<Array<EntryWhereInput>>;
  author?: InputMaybe<UserRelationFilter>;
  authorId?: InputMaybe<StringFilter>;
  categories?: InputMaybe<CategoryListRelationFilter>;
  categoryId?: InputMaybe<StringNullableFilter>;
  comments?: InputMaybe<CommentListRelationFilter>;
  content?: InputMaybe<JsonNullableListFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  featuredImage?: InputMaybe<JsonNullableListFilter>;
  id?: InputMaybe<StringFilter>;
  published?: InputMaybe<BoolFilter>;
  title?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeNullableFilter>;
};

export type EntryWhereUniqueInput = {
  authorId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
};

export type EnumCommentReactionsNullableListFilter = {
  equals?: InputMaybe<Array<CommentReactions>>;
  has?: InputMaybe<CommentReactions>;
  hasEvery?: InputMaybe<Array<CommentReactions>>;
  hasSome?: InputMaybe<Array<CommentReactions>>;
  isEmpty?: InputMaybe<Scalars['Boolean']>;
};

export type EnumGenderNullableFilter = {
  equals?: InputMaybe<Gender>;
  in?: InputMaybe<Array<Gender>>;
  not?: InputMaybe<NestedEnumGenderNullableFilter>;
  notIn?: InputMaybe<Array<Gender>>;
};

export type EnumMediaItemDestinationNullableFilter = {
  equals?: InputMaybe<MediaItemDestination>;
  in?: InputMaybe<Array<MediaItemDestination>>;
  not?: InputMaybe<NestedEnumMediaItemDestinationNullableFilter>;
  notIn?: InputMaybe<Array<MediaItemDestination>>;
};

export type EnumMimeTypesNullableFilter = {
  equals?: InputMaybe<MimeTypes>;
  in?: InputMaybe<Array<MimeTypes>>;
  not?: InputMaybe<NestedEnumMimeTypesNullableFilter>;
  notIn?: InputMaybe<Array<MimeTypes>>;
};

export type EnumPronounsNullableFilter = {
  equals?: InputMaybe<Pronouns>;
  in?: InputMaybe<Array<Pronouns>>;
  not?: InputMaybe<NestedEnumPronounsNullableFilter>;
  notIn?: InputMaybe<Array<Pronouns>>;
};

export type EnumRoleNullableFilter = {
  equals?: InputMaybe<Role>;
  in?: InputMaybe<Array<Role>>;
  not?: InputMaybe<NestedEnumRoleNullableFilter>;
  notIn?: InputMaybe<Array<Role>>;
};

export type EnumUserStatusNullableFilter = {
  equals?: InputMaybe<UserStatus>;
  in?: InputMaybe<Array<UserStatus>>;
  not?: InputMaybe<NestedEnumUserStatusNullableFilter>;
  notIn?: InputMaybe<Array<UserStatus>>;
};

export type FindManyEntriessPaginatedInput = {
  cursor?: InputMaybe<EntryWhereUniqueInput>;
  distinct?: InputMaybe<Array<EntryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EntryOrderByWithRelationAndSearchRelevanceInput>>;
  pagination: PaginationArgsInput;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EntryWhereInput>;
};

export type FindManyMediaItemsInput = {
  cursor?: InputMaybe<MediaItemWhereUniqueInput>;
  distinct?: InputMaybe<Array<MediaItemScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MediaItemOrderByWithRelationAndSearchRelevanceInput>>;
  pagination?: InputMaybe<PaginationArgsInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MediaItemWhereInput>;
};

export type FindManyProfilesPaginatedInput = {
  cursor?: InputMaybe<ProfileWhereUniqueInput>;
  distinct?: InputMaybe<Array<ProfileScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ProfileOrderByWithRelationAndSearchRelevanceInput>>;
  pagination: PaginationArgsInput;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProfileWhereInput>;
};

export type FindManyUsersPaginatedInput = {
  cursor?: InputMaybe<UserWhereUniqueInput>;
  distinct?: InputMaybe<Array<UserScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<UserOrderByWithRelationAndSearchRelevanceInput>>;
  pagination?: InputMaybe<PaginationArgsInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<UserWhereInput>;
};

export type FloatNullableFilter = {
  equals?: InputMaybe<Scalars['Float']>;
  gt?: InputMaybe<Scalars['Float']>;
  gte?: InputMaybe<Scalars['Float']>;
  in?: InputMaybe<Array<Scalars['Float']>>;
  lt?: InputMaybe<Scalars['Float']>;
  lte?: InputMaybe<Scalars['Float']>;
  not?: InputMaybe<NestedFloatNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

export enum Gender {
  Female = 'FEMALE',
  Male = 'MALE',
  Other = 'OTHER',
  Uncertain = 'UNCERTAIN'
}

export type IntNullableFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type JsonNullableFilter = {
  array_contains?: InputMaybe<Scalars['JSON']>;
  array_ends_with?: InputMaybe<Scalars['JSON']>;
  array_starts_with?: InputMaybe<Scalars['JSON']>;
  equals?: InputMaybe<Scalars['JSON']>;
  gt?: InputMaybe<Scalars['JSON']>;
  gte?: InputMaybe<Scalars['JSON']>;
  lt?: InputMaybe<Scalars['JSON']>;
  lte?: InputMaybe<Scalars['JSON']>;
  not?: InputMaybe<Scalars['JSON']>;
  path?: InputMaybe<Array<Scalars['String']>>;
  string_contains?: InputMaybe<Scalars['String']>;
  string_ends_with?: InputMaybe<Scalars['String']>;
  string_starts_with?: InputMaybe<Scalars['String']>;
};

export type JsonNullableListFilter = {
  equals?: InputMaybe<Array<Scalars['JSON']>>;
  has?: InputMaybe<Scalars['JSON']>;
  hasEvery?: InputMaybe<Array<Scalars['JSON']>>;
  hasSome?: InputMaybe<Array<Scalars['JSON']>>;
  isEmpty?: InputMaybe<Scalars['Boolean']>;
};

export type JwtDecoded = {
  __typename?: 'JwtDecoded';
  header: JwtHeaders;
  payload: JwtPayload;
  signature: Scalars['String'];
};

export type JwtHeaders = {
  __typename?: 'JwtHeaders';
  alg: AlgorithmType;
  typ: Scalars['String'];
};

export type JwtPayload = {
  __typename?: 'JwtPayload';
  exp?: Maybe<Scalars['BigInt']>;
  iat?: Maybe<Scalars['BigInt']>;
  userId?: Maybe<Scalars['String']>;
};

export type LoginInput = {
  email?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
};

export type MediaItem = {
  __typename?: 'MediaItem';
  fileLastModified?: Maybe<Scalars['DateTime']>;
  height?: Maybe<Scalars['Float']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  quality?: Maybe<Scalars['Int']>;
  size?: Maybe<Scalars['String']>;
  src?: Maybe<Scalars['String']>;
  srcSet?: Maybe<Scalars['String']>;
  type?: Maybe<MimeTypes>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  uploadedAt: Scalars['DateTime'];
  user: User;
  userId: Scalars['String'];
  width?: Maybe<Scalars['Float']>;
};

export type MediaItemConnection = {
  __typename?: 'MediaItemConnection';
  edges: Array<MediaItemEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type MediaItemCreateManyUserInput = {
  ariaLabel?: InputMaybe<Scalars['String']>;
  caption?: InputMaybe<Scalars['String']>;
  destination?: InputMaybe<MediaItemDestination>;
  fileLastModified?: InputMaybe<Scalars['DateTime']>;
  height?: InputMaybe<Scalars['Float']>;
  id?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  quality?: InputMaybe<Scalars['Int']>;
  size?: InputMaybe<Scalars['String']>;
  src?: InputMaybe<Scalars['String']>;
  srcSet?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<MimeTypes>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  uploadedAt?: InputMaybe<Scalars['DateTime']>;
  width?: InputMaybe<Scalars['Float']>;
};

export type MediaItemCreateManyUserInputEnvelope = {
  data: Array<MediaItemCreateManyUserInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type MediaItemCreateNestedManyWithoutUserInput = {
  connect?: InputMaybe<Array<MediaItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<MediaItemCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<MediaItemCreateWithoutUserInput>>;
  createMany?: InputMaybe<MediaItemCreateManyUserInputEnvelope>;
};

export type MediaItemCreateOrConnectWithoutUserInput = {
  create: MediaItemCreateWithoutUserInput;
  where: MediaItemWhereUniqueInput;
};

export type MediaItemCreateWithoutUserInput = {
  ariaLabel?: InputMaybe<Scalars['String']>;
  caption?: InputMaybe<Scalars['String']>;
  destination?: InputMaybe<MediaItemDestination>;
  fileLastModified?: InputMaybe<Scalars['DateTime']>;
  height?: InputMaybe<Scalars['Float']>;
  id?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  quality?: InputMaybe<Scalars['Int']>;
  size?: InputMaybe<Scalars['String']>;
  src?: InputMaybe<Scalars['String']>;
  srcSet?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<MimeTypes>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  uploadedAt?: InputMaybe<Scalars['DateTime']>;
  width?: InputMaybe<Scalars['Float']>;
};

export enum MediaItemDestination {
  Avatar = 'AVATAR',
  CommentAttachment = 'COMMENT_ATTACHMENT',
  CoverImage = 'COVER_IMAGE',
  EntryAttachment = 'ENTRY_ATTACHMENT',
  FeaturedImage = 'FEATURED_IMAGE'
}

export type MediaItemEdge = {
  __typename?: 'MediaItemEdge';
  cursor: Scalars['String'];
  node: MediaItem;
};

export type MediaItemListRelationFilter = {
  every?: InputMaybe<MediaItemWhereInput>;
  none?: InputMaybe<MediaItemWhereInput>;
  some?: InputMaybe<MediaItemWhereInput>;
};

export type MediaItemNameUserIdCompoundUniqueInput = {
  name: Scalars['String'];
  userId: Scalars['String'];
};

export type MediaItemOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum MediaItemOrderByRelevanceFieldEnum {
  AriaLabel = 'ariaLabel',
  Caption = 'caption',
  Id = 'id',
  Name = 'name',
  Size = 'size',
  Src = 'src',
  SrcSet = 'srcSet',
  Title = 'title',
  UserId = 'userId'
}

export type MediaItemOrderByRelevanceInput = {
  fields: Array<MediaItemOrderByRelevanceFieldEnum>;
  search: Scalars['String'];
  sort: SortOrder;
};

export type MediaItemOrderByWithRelationAndSearchRelevanceInput = {
  _relevance?: InputMaybe<MediaItemOrderByRelevanceInput>;
  ariaLabel?: InputMaybe<SortOrder>;
  caption?: InputMaybe<SortOrder>;
  destination?: InputMaybe<SortOrder>;
  fileLastModified?: InputMaybe<SortOrder>;
  height?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  quality?: InputMaybe<SortOrder>;
  size?: InputMaybe<SortOrder>;
  src?: InputMaybe<SortOrder>;
  srcSet?: InputMaybe<SortOrder>;
  title?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  uploadedAt?: InputMaybe<SortOrder>;
  user?: InputMaybe<UserOrderByWithRelationAndSearchRelevanceInput>;
  userId?: InputMaybe<SortOrder>;
  width?: InputMaybe<SortOrder>;
};

export enum MediaItemScalarFieldEnum {
  AriaLabel = 'ariaLabel',
  Caption = 'caption',
  Destination = 'destination',
  FileLastModified = 'fileLastModified',
  Height = 'height',
  Id = 'id',
  Name = 'name',
  Quality = 'quality',
  Size = 'size',
  Src = 'src',
  SrcSet = 'srcSet',
  Title = 'title',
  Type = 'type',
  UpdatedAt = 'updatedAt',
  UploadedAt = 'uploadedAt',
  UserId = 'userId',
  Width = 'width'
}

export type MediaItemWhereInput = {
  AND?: InputMaybe<Array<MediaItemWhereInput>>;
  NOT?: InputMaybe<Array<MediaItemWhereInput>>;
  OR?: InputMaybe<Array<MediaItemWhereInput>>;
  ariaLabel?: InputMaybe<StringNullableFilter>;
  caption?: InputMaybe<StringNullableFilter>;
  destination?: InputMaybe<EnumMediaItemDestinationNullableFilter>;
  fileLastModified?: InputMaybe<DateTimeNullableFilter>;
  height?: InputMaybe<FloatNullableFilter>;
  id?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringNullableFilter>;
  quality?: InputMaybe<IntNullableFilter>;
  size?: InputMaybe<StringNullableFilter>;
  src?: InputMaybe<StringNullableFilter>;
  srcSet?: InputMaybe<StringNullableFilter>;
  title?: InputMaybe<StringNullableFilter>;
  type?: InputMaybe<EnumMimeTypesNullableFilter>;
  updatedAt?: InputMaybe<DateTimeNullableFilter>;
  uploadedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserRelationFilter>;
  userId?: InputMaybe<StringFilter>;
  width?: InputMaybe<FloatNullableFilter>;
};

export type MediaItemWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
  name_userId?: InputMaybe<MediaItemNameUserIdCompoundUniqueInput>;
};

export enum MimeTypes {
  Avif = 'AVIF',
  Bmp = 'BMP',
  Gif = 'GIF',
  Jpeg = 'JPEG',
  Png = 'PNG',
  Svg = 'SVG',
  Tiff = 'TIFF',
  Webp = 'WEBP'
}

export type Mutation = {
  __typename?: 'Mutation';
  changePassword: User;
  createEntry: Entry;
  createProfile: Profile;
  getUserFromAccessToken: User;
  getViewerRefreshToken: Token;
  login: Token;
  register: AuthSansSession;
  registerNewUser: AuthDetailed;
  signin: AuthDetailed;
  signup: Token;
  updateUserPassword: User;
  userFromAccessTokenDecoded: AuthDetailed;
};


export type MutationChangePasswordArgs = {
  changePasswordInput: ChangePasswordInput;
};


export type MutationCreateEntryArgs = {
  createInput: EntryCreateInput;
};


export type MutationCreateProfileArgs = {
  data: ProfileCreateInput;
  userId: Scalars['String'];
};


export type MutationGetUserFromAccessTokenArgs = {
  token: Scalars['String'];
};


export type MutationLoginArgs = {
  data: LoginInput;
};


export type MutationRegisterArgs = {
  dataRegister: SignupInput;
};


export type MutationRegisterNewUserArgs = {
  userCreateInput: UserCreateMutationInput;
};


export type MutationSigninArgs = {
  userloginInput: LoginInput;
};


export type MutationSignupArgs = {
  data: SignupInput;
};


export type MutationUpdateUserPasswordArgs = {
  passwordInput: ChangePasswordInput;
};


export type MutationUserFromAccessTokenDecodedArgs = {
  token: Scalars['String'];
};

export type NestedBoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolFilter>;
};

export type NestedDateTimeFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type NestedDateTimeNullableFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type NestedEnumGenderNullableFilter = {
  equals?: InputMaybe<Gender>;
  in?: InputMaybe<Array<Gender>>;
  not?: InputMaybe<NestedEnumGenderNullableFilter>;
  notIn?: InputMaybe<Array<Gender>>;
};

export type NestedEnumMediaItemDestinationNullableFilter = {
  equals?: InputMaybe<MediaItemDestination>;
  in?: InputMaybe<Array<MediaItemDestination>>;
  not?: InputMaybe<NestedEnumMediaItemDestinationNullableFilter>;
  notIn?: InputMaybe<Array<MediaItemDestination>>;
};

export type NestedEnumMimeTypesNullableFilter = {
  equals?: InputMaybe<MimeTypes>;
  in?: InputMaybe<Array<MimeTypes>>;
  not?: InputMaybe<NestedEnumMimeTypesNullableFilter>;
  notIn?: InputMaybe<Array<MimeTypes>>;
};

export type NestedEnumPronounsNullableFilter = {
  equals?: InputMaybe<Pronouns>;
  in?: InputMaybe<Array<Pronouns>>;
  not?: InputMaybe<NestedEnumPronounsNullableFilter>;
  notIn?: InputMaybe<Array<Pronouns>>;
};

export type NestedEnumRoleNullableFilter = {
  equals?: InputMaybe<Role>;
  in?: InputMaybe<Array<Role>>;
  not?: InputMaybe<NestedEnumRoleNullableFilter>;
  notIn?: InputMaybe<Array<Role>>;
};

export type NestedEnumUserStatusNullableFilter = {
  equals?: InputMaybe<UserStatus>;
  in?: InputMaybe<Array<UserStatus>>;
  not?: InputMaybe<NestedEnumUserStatusNullableFilter>;
  notIn?: InputMaybe<Array<UserStatus>>;
};

export type NestedFloatNullableFilter = {
  equals?: InputMaybe<Scalars['Float']>;
  gt?: InputMaybe<Scalars['Float']>;
  gte?: InputMaybe<Scalars['Float']>;
  in?: InputMaybe<Array<Scalars['Float']>>;
  lt?: InputMaybe<Scalars['Float']>;
  lte?: InputMaybe<Scalars['Float']>;
  not?: InputMaybe<NestedFloatNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

export type NestedIntNullableFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type NestedStringFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  search?: InputMaybe<Scalars['String']>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type NestedStringNullableFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  search?: InputMaybe<Scalars['String']>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type Node = {
  id: Scalars['ID'];
};

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor?: Maybe<Scalars['String']>;
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor?: Maybe<Scalars['String']>;
};

export type PaginationArgsInput = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type Profile = {
  __typename?: 'Profile';
  activiyFeed?: Maybe<Array<Scalars['JSONObject']>>;
  bio?: Maybe<Array<Scalars['JSONObject']>>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  coverPhoto?: Maybe<Array<Scalars['JSONObject']>>;
  dob?: Maybe<Scalars['String']>;
  gender?: Maybe<Gender>;
  id: Scalars['ID'];
  lastSeen?: Maybe<Scalars['DateTime']>;
  memberSince: Scalars['DateTime'];
  occupation?: Maybe<Scalars['String']>;
  phoneNumber?: Maybe<Scalars['String']>;
  pronouns?: Maybe<Pronouns>;
  recentActivity?: Maybe<Array<Scalars['JSONObject']>>;
  user: User;
  userId: Scalars['String'];
  userInProfile: User;
};

export type ProfileConnection = {
  __typename?: 'ProfileConnection';
  edges: Array<ProfileEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ProfileCreateInput = {
  activiyFeed?: InputMaybe<ProfileCreateactiviyFeedInput>;
  bio?: InputMaybe<ProfileCreatebioInput>;
  city?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  coverPhoto?: InputMaybe<ProfileCreatecoverPhotoInput>;
  dob?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<Gender>;
  id?: InputMaybe<Scalars['String']>;
  lastSeen?: InputMaybe<Scalars['DateTime']>;
  memberSince?: InputMaybe<Scalars['DateTime']>;
  occupation?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  pronouns?: InputMaybe<Pronouns>;
  recentActivity?: InputMaybe<ProfileCreaterecentActivityInput>;
  user: UserCreateNestedOneWithoutProfileInput;
};

export type ProfileCreateNestedOneWithoutUserInput = {
  connect?: InputMaybe<ProfileWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProfileCreateOrConnectWithoutUserInput>;
  create?: InputMaybe<ProfileCreateWithoutUserInput>;
};

export type ProfileCreateOrConnectWithoutUserInput = {
  create: ProfileCreateWithoutUserInput;
  where: ProfileWhereUniqueInput;
};

export type ProfileCreateWithoutUserInput = {
  activiyFeed?: InputMaybe<ProfileCreateactiviyFeedInput>;
  bio?: InputMaybe<ProfileCreatebioInput>;
  city?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  coverPhoto?: InputMaybe<ProfileCreatecoverPhotoInput>;
  dob?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<Gender>;
  id?: InputMaybe<Scalars['String']>;
  lastSeen?: InputMaybe<Scalars['DateTime']>;
  memberSince?: InputMaybe<Scalars['DateTime']>;
  occupation?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  pronouns?: InputMaybe<Pronouns>;
  recentActivity?: InputMaybe<ProfileCreaterecentActivityInput>;
};

export type ProfileCreateactiviyFeedInput = {
  set: Array<Scalars['JSON']>;
};

export type ProfileCreatebioInput = {
  set: Array<Scalars['JSON']>;
};

export type ProfileCreatecoverPhotoInput = {
  set: Array<Scalars['JSON']>;
};

export type ProfileCreaterecentActivityInput = {
  set: Array<Scalars['JSON']>;
};

export type ProfileEdge = {
  __typename?: 'ProfileEdge';
  cursor: Scalars['String'];
  node: Profile;
};

export enum ProfileOrderByRelevanceFieldEnum {
  City = 'city',
  Country = 'country',
  Dob = 'dob',
  Id = 'id',
  Occupation = 'occupation',
  PhoneNumber = 'phoneNumber',
  UserId = 'userId'
}

export type ProfileOrderByRelevanceInput = {
  fields: Array<ProfileOrderByRelevanceFieldEnum>;
  search: Scalars['String'];
  sort: SortOrder;
};

export type ProfileOrderByWithRelationAndSearchRelevanceInput = {
  _relevance?: InputMaybe<ProfileOrderByRelevanceInput>;
  activiyFeed?: InputMaybe<SortOrder>;
  bio?: InputMaybe<SortOrder>;
  city?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  coverPhoto?: InputMaybe<SortOrder>;
  dob?: InputMaybe<SortOrder>;
  gender?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastSeen?: InputMaybe<SortOrder>;
  memberSince?: InputMaybe<SortOrder>;
  occupation?: InputMaybe<SortOrder>;
  phoneNumber?: InputMaybe<SortOrder>;
  pronouns?: InputMaybe<SortOrder>;
  recentActivity?: InputMaybe<SortOrder>;
  user?: InputMaybe<UserOrderByWithRelationAndSearchRelevanceInput>;
  userId?: InputMaybe<SortOrder>;
};

export type ProfileRelationFilter = {
  is?: InputMaybe<ProfileWhereInput>;
  isNot?: InputMaybe<ProfileWhereInput>;
};

export enum ProfileScalarFieldEnum {
  ActiviyFeed = 'activiyFeed',
  Bio = 'bio',
  City = 'city',
  Country = 'country',
  CoverPhoto = 'coverPhoto',
  Dob = 'dob',
  Gender = 'gender',
  Id = 'id',
  LastSeen = 'lastSeen',
  MemberSince = 'memberSince',
  Occupation = 'occupation',
  PhoneNumber = 'phoneNumber',
  Pronouns = 'pronouns',
  RecentActivity = 'recentActivity',
  UserId = 'userId'
}

export type ProfileWhereInput = {
  AND?: InputMaybe<Array<ProfileWhereInput>>;
  NOT?: InputMaybe<Array<ProfileWhereInput>>;
  OR?: InputMaybe<Array<ProfileWhereInput>>;
  activiyFeed?: InputMaybe<JsonNullableListFilter>;
  bio?: InputMaybe<JsonNullableListFilter>;
  city?: InputMaybe<StringNullableFilter>;
  country?: InputMaybe<StringNullableFilter>;
  coverPhoto?: InputMaybe<JsonNullableListFilter>;
  dob?: InputMaybe<StringNullableFilter>;
  gender?: InputMaybe<EnumGenderNullableFilter>;
  id?: InputMaybe<StringFilter>;
  lastSeen?: InputMaybe<DateTimeNullableFilter>;
  memberSince?: InputMaybe<DateTimeFilter>;
  occupation?: InputMaybe<StringNullableFilter>;
  phoneNumber?: InputMaybe<StringNullableFilter>;
  pronouns?: InputMaybe<EnumPronounsNullableFilter>;
  recentActivity?: InputMaybe<JsonNullableListFilter>;
  user?: InputMaybe<UserRelationFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type ProfileWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['String']>;
};

export type ProfilesInput = {
  bioFilter?: InputMaybe<JsonNullableFilter>;
  dobFilter?: InputMaybe<StringNullableFilter>;
  genderFilter?: InputMaybe<EnumGenderNullableFilter>;
  orderBy?: InputMaybe<ProfileOrderByWithRelationAndSearchRelevanceInput>;
  paginationArgs?: InputMaybe<PaginationArgsInput>;
  pronounsFilter?: InputMaybe<EnumPronounsNullableFilter>;
};

export enum Pronouns {
  HeHimHis = 'HE_HIM_HIS',
  NotListed = 'NOT_LISTED',
  PreferNotToSay = 'PREFER_NOT_TO_SAY',
  SheHerHers = 'SHE_HER_HERS',
  TheyThemTheirs = 'THEY_THEM_THEIRS'
}

export type Query = {
  __typename?: 'Query';
  contentNodesUnion: ContentNodes;
  entryById: Entry;
  findUniqueMediaItem: MediaItem;
  getViewer: AuthDetailed;
  hello: Scalars['String'];
  helloWorld: Scalars['String'];
  listEntries: EntryConnection;
  listMediaItems: MediaItemConnection;
  listProfiles: ProfileConnection;
  listUsers: UserConnection;
  me: AuthDetailed;
  node?: Maybe<Node>;
  profileByRelayId: Profile;
  profiles: ProfileConnection;
  userById: User;
  userByRelayId: User;
  userPosts: Array<Entry>;
  viewer: ViewerDetailed;
};


export type QueryContentNodesUnionArgs = {
  findManyEntriesPaginatedInput: FindManyEntriessPaginatedInput;
  findManyMediaItemsPaginated?: InputMaybe<FindManyMediaItemsInput>;
  findManyUsersPaginatedInput?: InputMaybe<FindManyUsersPaginatedInput>;
};


export type QueryEntryByIdArgs = {
  id: Scalars['String'];
};


export type QueryFindUniqueMediaItemArgs = {
  mediaItemId: Scalars['String'];
};


export type QueryHelloArgs = {
  name: Scalars['String'];
};


export type QueryListEntriesArgs = {
  findManyEntriesPaginatedInput: FindManyEntriessPaginatedInput;
};


export type QueryListMediaItemsArgs = {
  findManyMediaItemsPaginated?: InputMaybe<FindManyMediaItemsInput>;
};


export type QueryListProfilesArgs = {
  findManyProfilesPaginatedInput: FindManyProfilesPaginatedInput;
};


export type QueryListUsersArgs = {
  findManyUsersPaginatedInput?: InputMaybe<FindManyUsersPaginatedInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
};


export type QueryProfilesArgs = {
  profilesArgs: ProfilesInput;
};


export type QueryUserByIdArgs = {
  id: Scalars['String'];
};


export type QueryUserByRelayIdArgs = {
  cursor: Scalars['String'];
};


export type QueryUserPostsArgs = {
  userId: Scalars['ID'];
};

export enum QueryMode {
  Default = 'default',
  Insensitive = 'insensitive'
}

export enum Role {
  Admin = 'ADMIN',
  Maintainer = 'MAINTAINER',
  Superadmin = 'SUPERADMIN',
  User = 'USER'
}

export type Session = {
  __typename?: 'Session';
  accessToken?: Maybe<Scalars['String']>;
  alg?: Maybe<Scalars['String']>;
  exp?: Maybe<Scalars['Int']>;
  iat?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  lastVerified?: Maybe<Scalars['DateTime']>;
  provider?: Maybe<Scalars['String']>;
  refreshToken?: Maybe<Scalars['String']>;
  scopes?: Maybe<Array<Scalars['String']>>;
  signature?: Maybe<Scalars['String']>;
  tokenState?: Maybe<Scalars['String']>;
  user?: Maybe<User>;
  userId: Scalars['String'];
};

export type SessionCreateManyUserInput = {
  accessToken?: InputMaybe<Scalars['String']>;
  alg?: InputMaybe<Scalars['String']>;
  exp?: InputMaybe<Scalars['Int']>;
  iat?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  lastVerified?: InputMaybe<Scalars['DateTime']>;
  provider?: InputMaybe<Scalars['String']>;
  refreshToken?: InputMaybe<Scalars['String']>;
  scopes?: InputMaybe<SessionCreateManyscopesInput>;
  signature?: InputMaybe<Scalars['String']>;
  tokenState?: InputMaybe<Scalars['String']>;
};

export type SessionCreateManyUserInputEnvelope = {
  data: Array<SessionCreateManyUserInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type SessionCreateManyscopesInput = {
  set: Array<Scalars['String']>;
};

export type SessionCreateNestedManyWithoutUserInput = {
  connect?: InputMaybe<Array<SessionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SessionCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<SessionCreateWithoutUserInput>>;
  createMany?: InputMaybe<SessionCreateManyUserInputEnvelope>;
};

export type SessionCreateOrConnectWithoutUserInput = {
  create: SessionCreateWithoutUserInput;
  where: SessionWhereUniqueInput;
};

export type SessionCreateWithoutUserInput = {
  accessToken?: InputMaybe<Scalars['String']>;
  alg?: InputMaybe<Scalars['String']>;
  exp?: InputMaybe<Scalars['Int']>;
  iat?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  lastVerified?: InputMaybe<Scalars['DateTime']>;
  provider?: InputMaybe<Scalars['String']>;
  refreshToken?: InputMaybe<Scalars['String']>;
  scopes?: InputMaybe<SessionCreatescopesInput>;
  signature?: InputMaybe<Scalars['String']>;
  tokenState?: InputMaybe<Scalars['String']>;
};

export type SessionCreatescopesInput = {
  set: Array<Scalars['String']>;
};

export type SessionListRelationFilter = {
  every?: InputMaybe<SessionWhereInput>;
  none?: InputMaybe<SessionWhereInput>;
  some?: InputMaybe<SessionWhereInput>;
};

export type SessionOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type SessionWhereInput = {
  AND?: InputMaybe<Array<SessionWhereInput>>;
  NOT?: InputMaybe<Array<SessionWhereInput>>;
  OR?: InputMaybe<Array<SessionWhereInput>>;
  accessToken?: InputMaybe<StringNullableFilter>;
  alg?: InputMaybe<StringNullableFilter>;
  exp?: InputMaybe<IntNullableFilter>;
  iat?: InputMaybe<IntNullableFilter>;
  id?: InputMaybe<StringFilter>;
  lastVerified?: InputMaybe<DateTimeNullableFilter>;
  provider?: InputMaybe<StringNullableFilter>;
  refreshToken?: InputMaybe<StringNullableFilter>;
  scopes?: InputMaybe<StringNullableListFilter>;
  signature?: InputMaybe<StringNullableFilter>;
  tokenState?: InputMaybe<StringNullableFilter>;
  user?: InputMaybe<UserRelationFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type SessionWhereUniqueInput = {
  userId?: InputMaybe<Scalars['String']>;
};

export type SignupInput = {
  email: Scalars['String'];
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  password: Scalars['String'];
};

export enum SortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type StringFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  search?: InputMaybe<Scalars['String']>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type StringNullableFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  search?: InputMaybe<Scalars['String']>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type StringNullableListFilter = {
  equals?: InputMaybe<Array<Scalars['String']>>;
  has?: InputMaybe<Scalars['String']>;
  hasEvery?: InputMaybe<Array<Scalars['String']>>;
  hasSome?: InputMaybe<Array<Scalars['String']>>;
  isEmpty?: InputMaybe<Scalars['Boolean']>;
};

export type Subscription = {
  __typename?: 'Subscription';
  entryCreated: Entry;
  profileCreated: Profile;
};

export type Token = {
  __typename?: 'Token';
  /** JWT access token */
  accessToken?: Maybe<Scalars['String']>;
  /** JWT refresh token */
  refreshToken?: Maybe<Scalars['String']>;
};

export type TypesUnion = Entry | MediaItem | User;

export type User = {
  __typename?: 'User';
  _count?: Maybe<UserCount>;
  accounts?: Maybe<Array<Account>>;
  categories?: Maybe<Array<Category>>;
  comments?: Maybe<Array<Comment>>;
  connections?: Maybe<Array<Connection>>;
  /** Identifies the date and time when the user was created. */
  createdAt: Scalars['DateTime'];
  email: Scalars['String'];
  emailVerified?: Maybe<Scalars['DateTime']>;
  entries?: Maybe<Array<Entry>>;
  firstName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  image: Array<Scalars['JSONObject']>;
  lastName?: Maybe<Scalars['String']>;
  mediaItems?: Maybe<Array<MediaItem>>;
  password: Scalars['String'];
  profile?: Maybe<Profile>;
  role?: Maybe<Role>;
  sessions?: Maybe<Array<Session>>;
  status: UserStatus;
  /** Identifies the date and time when the user was last updated. */
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type UserConnection = {
  __typename?: 'UserConnection';
  edges: Array<UserEdge>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type UserCount = {
  __typename?: 'UserCount';
  accounts: Scalars['Int'];
  categories: Scalars['Int'];
  comments: Scalars['Int'];
  connections: Scalars['Int'];
  entries: Scalars['Int'];
  mediaItems: Scalars['Int'];
  sessions: Scalars['Int'];
};

export type UserCreateMutationInput = {
  accounts?: InputMaybe<AccountCreateNestedManyWithoutUserInput>;
  categories?: InputMaybe<CategoryCreateNestedManyWithoutCreatorInput>;
  comments?: InputMaybe<CommentCreateNestedManyWithoutAuthorInput>;
  connections?: InputMaybe<ConnectionCreateNestedManyWithoutOwnerInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  email: Scalars['String'];
  emailVerified?: InputMaybe<Scalars['DateTime']>;
  entries?: InputMaybe<EntryCreateNestedManyWithoutAuthorInput>;
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<UserCreateimageInput>;
  lastName?: InputMaybe<Scalars['String']>;
  mediaItems?: InputMaybe<MediaItemCreateNestedManyWithoutUserInput>;
  password?: InputMaybe<Scalars['String']>;
  profile?: InputMaybe<ProfileCreateNestedOneWithoutUserInput>;
  role?: InputMaybe<Role>;
  sessions?: InputMaybe<SessionCreateNestedManyWithoutUserInput>;
  status?: InputMaybe<UserStatus>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type UserCreateNestedOneWithoutCategoriesInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutCategoriesInput>;
  create?: InputMaybe<UserCreateWithoutCategoriesInput>;
};

export type UserCreateNestedOneWithoutCommentsInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutCommentsInput>;
  create?: InputMaybe<UserCreateWithoutCommentsInput>;
};

export type UserCreateNestedOneWithoutEntriesInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutEntriesInput>;
  create?: InputMaybe<UserCreateWithoutEntriesInput>;
};

export type UserCreateNestedOneWithoutProfileInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutProfileInput>;
  create?: InputMaybe<UserCreateWithoutProfileInput>;
};

export type UserCreateOrConnectWithoutCategoriesInput = {
  create: UserCreateWithoutCategoriesInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutCommentsInput = {
  create: UserCreateWithoutCommentsInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutEntriesInput = {
  create: UserCreateWithoutEntriesInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutProfileInput = {
  create: UserCreateWithoutProfileInput;
  where: UserWhereUniqueInput;
};

export type UserCreateWithoutCategoriesInput = {
  accounts?: InputMaybe<AccountCreateNestedManyWithoutUserInput>;
  comments?: InputMaybe<CommentCreateNestedManyWithoutAuthorInput>;
  connections?: InputMaybe<ConnectionCreateNestedManyWithoutOwnerInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  email: Scalars['String'];
  emailVerified?: InputMaybe<Scalars['DateTime']>;
  entries?: InputMaybe<EntryCreateNestedManyWithoutAuthorInput>;
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<UserCreateimageInput>;
  lastName?: InputMaybe<Scalars['String']>;
  mediaItems?: InputMaybe<MediaItemCreateNestedManyWithoutUserInput>;
  password?: InputMaybe<Scalars['String']>;
  profile?: InputMaybe<ProfileCreateNestedOneWithoutUserInput>;
  role?: InputMaybe<Role>;
  sessions?: InputMaybe<SessionCreateNestedManyWithoutUserInput>;
  status?: InputMaybe<UserStatus>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type UserCreateWithoutCommentsInput = {
  accounts?: InputMaybe<AccountCreateNestedManyWithoutUserInput>;
  categories?: InputMaybe<CategoryCreateNestedManyWithoutCreatorInput>;
  connections?: InputMaybe<ConnectionCreateNestedManyWithoutOwnerInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  email: Scalars['String'];
  emailVerified?: InputMaybe<Scalars['DateTime']>;
  entries?: InputMaybe<EntryCreateNestedManyWithoutAuthorInput>;
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<UserCreateimageInput>;
  lastName?: InputMaybe<Scalars['String']>;
  mediaItems?: InputMaybe<MediaItemCreateNestedManyWithoutUserInput>;
  password?: InputMaybe<Scalars['String']>;
  profile?: InputMaybe<ProfileCreateNestedOneWithoutUserInput>;
  role?: InputMaybe<Role>;
  sessions?: InputMaybe<SessionCreateNestedManyWithoutUserInput>;
  status?: InputMaybe<UserStatus>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type UserCreateWithoutEntriesInput = {
  accounts?: InputMaybe<AccountCreateNestedManyWithoutUserInput>;
  categories?: InputMaybe<CategoryCreateNestedManyWithoutCreatorInput>;
  comments?: InputMaybe<CommentCreateNestedManyWithoutAuthorInput>;
  connections?: InputMaybe<ConnectionCreateNestedManyWithoutOwnerInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  email: Scalars['String'];
  emailVerified?: InputMaybe<Scalars['DateTime']>;
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<UserCreateimageInput>;
  lastName?: InputMaybe<Scalars['String']>;
  mediaItems?: InputMaybe<MediaItemCreateNestedManyWithoutUserInput>;
  password?: InputMaybe<Scalars['String']>;
  profile?: InputMaybe<ProfileCreateNestedOneWithoutUserInput>;
  role?: InputMaybe<Role>;
  sessions?: InputMaybe<SessionCreateNestedManyWithoutUserInput>;
  status?: InputMaybe<UserStatus>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type UserCreateWithoutProfileInput = {
  accounts?: InputMaybe<AccountCreateNestedManyWithoutUserInput>;
  categories?: InputMaybe<CategoryCreateNestedManyWithoutCreatorInput>;
  comments?: InputMaybe<CommentCreateNestedManyWithoutAuthorInput>;
  connections?: InputMaybe<ConnectionCreateNestedManyWithoutOwnerInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  email: Scalars['String'];
  emailVerified?: InputMaybe<Scalars['DateTime']>;
  entries?: InputMaybe<EntryCreateNestedManyWithoutAuthorInput>;
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<UserCreateimageInput>;
  lastName?: InputMaybe<Scalars['String']>;
  mediaItems?: InputMaybe<MediaItemCreateNestedManyWithoutUserInput>;
  password?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Role>;
  sessions?: InputMaybe<SessionCreateNestedManyWithoutUserInput>;
  status?: InputMaybe<UserStatus>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type UserCreateimageInput = {
  set: Array<Scalars['JSON']>;
};

export type UserEdge = {
  __typename?: 'UserEdge';
  cursor: Scalars['String'];
  node: User;
};

export enum UserOrderByRelevanceFieldEnum {
  Email = 'email',
  FirstName = 'firstName',
  Id = 'id',
  LastName = 'lastName',
  Password = 'password'
}

export type UserOrderByRelevanceInput = {
  fields: Array<UserOrderByRelevanceFieldEnum>;
  search: Scalars['String'];
  sort: SortOrder;
};

export type UserOrderByWithRelationAndSearchRelevanceInput = {
  _relevance?: InputMaybe<UserOrderByRelevanceInput>;
  accounts?: InputMaybe<AccountOrderByRelationAggregateInput>;
  categories?: InputMaybe<CategoryOrderByRelationAggregateInput>;
  comments?: InputMaybe<CommentOrderByRelationAggregateInput>;
  connections?: InputMaybe<ConnectionOrderByRelationAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  emailVerified?: InputMaybe<SortOrder>;
  entries?: InputMaybe<EntryOrderByRelationAggregateInput>;
  firstName?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  lastName?: InputMaybe<SortOrder>;
  mediaItems?: InputMaybe<MediaItemOrderByRelationAggregateInput>;
  password?: InputMaybe<SortOrder>;
  profile?: InputMaybe<ProfileOrderByWithRelationAndSearchRelevanceInput>;
  role?: InputMaybe<SortOrder>;
  sessions?: InputMaybe<SessionOrderByRelationAggregateInput>;
  status?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type UserRelationFilter = {
  is?: InputMaybe<UserWhereInput>;
  isNot?: InputMaybe<UserWhereInput>;
};

export enum UserScalarFieldEnum {
  CreatedAt = 'createdAt',
  Email = 'email',
  EmailVerified = 'emailVerified',
  FirstName = 'firstName',
  Id = 'id',
  Image = 'image',
  LastName = 'lastName',
  Password = 'password',
  Role = 'role',
  Status = 'status',
  UpdatedAt = 'updatedAt'
}

export enum UserStatus {
  Banned = 'BANNED',
  Deactivated = 'DEACTIVATED',
  Deleted = 'DELETED',
  Offline = 'OFFLINE',
  Online = 'ONLINE',
  Suspended = 'SUSPENDED'
}

export type UserWhereInput = {
  AND?: InputMaybe<Array<UserWhereInput>>;
  NOT?: InputMaybe<Array<UserWhereInput>>;
  OR?: InputMaybe<Array<UserWhereInput>>;
  accounts?: InputMaybe<AccountListRelationFilter>;
  categories?: InputMaybe<CategoryListRelationFilter>;
  comments?: InputMaybe<CommentListRelationFilter>;
  connections?: InputMaybe<ConnectionListRelationFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  email?: InputMaybe<StringFilter>;
  emailVerified?: InputMaybe<DateTimeNullableFilter>;
  entries?: InputMaybe<EntryListRelationFilter>;
  firstName?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<StringFilter>;
  image?: InputMaybe<JsonNullableListFilter>;
  lastName?: InputMaybe<StringNullableFilter>;
  mediaItems?: InputMaybe<MediaItemListRelationFilter>;
  password?: InputMaybe<StringFilter>;
  profile?: InputMaybe<ProfileRelationFilter>;
  role?: InputMaybe<EnumRoleNullableFilter>;
  sessions?: InputMaybe<SessionListRelationFilter>;
  status?: InputMaybe<EnumUserStatusNullableFilter>;
  updatedAt?: InputMaybe<DateTimeNullableFilter>;
};

export type UserWhereUniqueInput = {
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
};

export type ViewerDetailed = {
  __typename?: 'ViewerDetailed';
  _count?: Maybe<UserCount>;
  accessToken?: Maybe<Scalars['String']>;
  accounts?: Maybe<Array<Account>>;
  categories?: Maybe<Array<Category>>;
  comments?: Maybe<Array<Comment>>;
  connections?: Maybe<Array<Connection>>;
  /** Identifies the date and time when the user was created. */
  createdAt: Scalars['DateTime'];
  email: Scalars['String'];
  emailVerified?: Maybe<Scalars['DateTime']>;
  entries?: Maybe<Array<Entry>>;
  firstName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  image: Array<Scalars['JSONObject']>;
  lastName?: Maybe<Scalars['String']>;
  mediaItems?: Maybe<Array<MediaItem>>;
  password: Scalars['String'];
  profile?: Maybe<Profile>;
  refreshToken?: Maybe<Scalars['String']>;
  role?: Maybe<Role>;
  secret?: Maybe<Scalars['String']>;
  sessions?: Maybe<Array<Session>>;
  status: UserStatus;
  /** Identifies the date and time when the user was last updated. */
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  Account: ResolverTypeWrapper<Account>;
  AccountCreateManyUserInput: AccountCreateManyUserInput;
  AccountCreateManyUserInputEnvelope: AccountCreateManyUserInputEnvelope;
  AccountCreateNestedManyWithoutUserInput: AccountCreateNestedManyWithoutUserInput;
  AccountCreateOrConnectWithoutUserInput: AccountCreateOrConnectWithoutUserInput;
  AccountCreateWithoutUserInput: AccountCreateWithoutUserInput;
  AccountListRelationFilter: AccountListRelationFilter;
  AccountOrderByRelationAggregateInput: AccountOrderByRelationAggregateInput;
  AccountProviderProviderAccountIdCompoundUniqueInput: AccountProviderProviderAccountIdCompoundUniqueInput;
  AccountWhereInput: AccountWhereInput;
  AccountWhereUniqueInput: AccountWhereUniqueInput;
  AlgorithmType: AlgorithmType;
  Auth: ResolverTypeWrapper<Auth>;
  AuthDetailed: ResolverTypeWrapper<AuthDetailed>;
  AuthSansSession: ResolverTypeWrapper<AuthSansSession>;
  BaseTypeNodes: ResolverTypeWrapper<Omit<BaseTypeNodes, 'nodes'> & { nodes: Array<ResolversTypes['TypesUnion']> }>;
  BaseTypesEdge: ResolverTypeWrapper<Omit<BaseTypesEdge, 'node'> & { node: ResolversTypes['TypesUnion'] }>;
  BigInt: ResolverTypeWrapper<Scalars['BigInt']>;
  BoolFilter: BoolFilter;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  Category: ResolverTypeWrapper<Category>;
  CategoryCount: ResolverTypeWrapper<CategoryCount>;
  CategoryCreateManyCreatorInput: CategoryCreateManyCreatorInput;
  CategoryCreateManyCreatorInputEnvelope: CategoryCreateManyCreatorInputEnvelope;
  CategoryCreateNestedManyWithoutCreatorInput: CategoryCreateNestedManyWithoutCreatorInput;
  CategoryCreateNestedManyWithoutEntriesInput: CategoryCreateNestedManyWithoutEntriesInput;
  CategoryCreateOrConnectWithoutCreatorInput: CategoryCreateOrConnectWithoutCreatorInput;
  CategoryCreateOrConnectWithoutEntriesInput: CategoryCreateOrConnectWithoutEntriesInput;
  CategoryCreateWithoutCreatorInput: CategoryCreateWithoutCreatorInput;
  CategoryCreateWithoutEntriesInput: CategoryCreateWithoutEntriesInput;
  CategoryListRelationFilter: CategoryListRelationFilter;
  CategoryOrderByRelationAggregateInput: CategoryOrderByRelationAggregateInput;
  CategoryWhereInput: CategoryWhereInput;
  CategoryWhereUniqueInput: CategoryWhereUniqueInput;
  ChangePasswordInput: ChangePasswordInput;
  Comment: ResolverTypeWrapper<Comment>;
  CommentAuthorIdEntryIdCompoundUniqueInput: CommentAuthorIdEntryIdCompoundUniqueInput;
  CommentCreateManyAuthorInput: CommentCreateManyAuthorInput;
  CommentCreateManyAuthorInputEnvelope: CommentCreateManyAuthorInputEnvelope;
  CommentCreateManyEntryInput: CommentCreateManyEntryInput;
  CommentCreateManyEntryInputEnvelope: CommentCreateManyEntryInputEnvelope;
  CommentCreateManyreactionsInput: CommentCreateManyreactionsInput;
  CommentCreateNestedManyWithoutAuthorInput: CommentCreateNestedManyWithoutAuthorInput;
  CommentCreateNestedManyWithoutEntryInput: CommentCreateNestedManyWithoutEntryInput;
  CommentCreateOrConnectWithoutAuthorInput: CommentCreateOrConnectWithoutAuthorInput;
  CommentCreateOrConnectWithoutEntryInput: CommentCreateOrConnectWithoutEntryInput;
  CommentCreateWithoutAuthorInput: CommentCreateWithoutAuthorInput;
  CommentCreateWithoutEntryInput: CommentCreateWithoutEntryInput;
  CommentCreatereactionsInput: CommentCreatereactionsInput;
  CommentListRelationFilter: CommentListRelationFilter;
  CommentOrderByRelationAggregateInput: CommentOrderByRelationAggregateInput;
  CommentReactions: CommentReactions;
  CommentWhereInput: CommentWhereInput;
  CommentWhereUniqueInput: CommentWhereUniqueInput;
  Connection: ResolverTypeWrapper<Connection>;
  ConnectionCreateManyOwnerInput: ConnectionCreateManyOwnerInput;
  ConnectionCreateManyOwnerInputEnvelope: ConnectionCreateManyOwnerInputEnvelope;
  ConnectionCreateNestedManyWithoutOwnerInput: ConnectionCreateNestedManyWithoutOwnerInput;
  ConnectionCreateOrConnectWithoutOwnerInput: ConnectionCreateOrConnectWithoutOwnerInput;
  ConnectionCreateWithoutOwnerInput: ConnectionCreateWithoutOwnerInput;
  ConnectionListRelationFilter: ConnectionListRelationFilter;
  ConnectionOrderByRelationAggregateInput: ConnectionOrderByRelationAggregateInput;
  ConnectionWhereInput: ConnectionWhereInput;
  ConnectionWhereUniqueInput: ConnectionWhereUniqueInput;
  ContentNodes: ResolverTypeWrapper<ContentNodes>;
  DateTime: ResolverTypeWrapper<Scalars['DateTime']>;
  DateTimeFilter: DateTimeFilter;
  DateTimeNullableFilter: DateTimeNullableFilter;
  Entry: ResolverTypeWrapper<Entry>;
  EntryConnection: ResolverTypeWrapper<EntryConnection>;
  EntryCount: ResolverTypeWrapper<EntryCount>;
  EntryCreateInput: EntryCreateInput;
  EntryCreateManyAuthorInput: EntryCreateManyAuthorInput;
  EntryCreateManyAuthorInputEnvelope: EntryCreateManyAuthorInputEnvelope;
  EntryCreateManycontentInput: EntryCreateManycontentInput;
  EntryCreateManyfeaturedImageInput: EntryCreateManyfeaturedImageInput;
  EntryCreateNestedManyWithoutAuthorInput: EntryCreateNestedManyWithoutAuthorInput;
  EntryCreateNestedManyWithoutCategoriesInput: EntryCreateNestedManyWithoutCategoriesInput;
  EntryCreateNestedOneWithoutCommentsInput: EntryCreateNestedOneWithoutCommentsInput;
  EntryCreateOrConnectWithoutAuthorInput: EntryCreateOrConnectWithoutAuthorInput;
  EntryCreateOrConnectWithoutCategoriesInput: EntryCreateOrConnectWithoutCategoriesInput;
  EntryCreateOrConnectWithoutCommentsInput: EntryCreateOrConnectWithoutCommentsInput;
  EntryCreateWithoutAuthorInput: EntryCreateWithoutAuthorInput;
  EntryCreateWithoutCategoriesInput: EntryCreateWithoutCategoriesInput;
  EntryCreateWithoutCommentsInput: EntryCreateWithoutCommentsInput;
  EntryCreatecontentInput: EntryCreatecontentInput;
  EntryCreatefeaturedImageInput: EntryCreatefeaturedImageInput;
  EntryEdge: ResolverTypeWrapper<EntryEdge>;
  EntryListRelationFilter: EntryListRelationFilter;
  EntryOrderByRelationAggregateInput: EntryOrderByRelationAggregateInput;
  EntryOrderByRelevanceFieldEnum: EntryOrderByRelevanceFieldEnum;
  EntryOrderByRelevanceInput: EntryOrderByRelevanceInput;
  EntryOrderByWithRelationAndSearchRelevanceInput: EntryOrderByWithRelationAndSearchRelevanceInput;
  EntryRelationFilter: EntryRelationFilter;
  EntryScalarFieldEnum: EntryScalarFieldEnum;
  EntryWhereInput: EntryWhereInput;
  EntryWhereUniqueInput: EntryWhereUniqueInput;
  EnumCommentReactionsNullableListFilter: EnumCommentReactionsNullableListFilter;
  EnumGenderNullableFilter: EnumGenderNullableFilter;
  EnumMediaItemDestinationNullableFilter: EnumMediaItemDestinationNullableFilter;
  EnumMimeTypesNullableFilter: EnumMimeTypesNullableFilter;
  EnumPronounsNullableFilter: EnumPronounsNullableFilter;
  EnumRoleNullableFilter: EnumRoleNullableFilter;
  EnumUserStatusNullableFilter: EnumUserStatusNullableFilter;
  FindManyEntriessPaginatedInput: FindManyEntriessPaginatedInput;
  FindManyMediaItemsInput: FindManyMediaItemsInput;
  FindManyProfilesPaginatedInput: FindManyProfilesPaginatedInput;
  FindManyUsersPaginatedInput: FindManyUsersPaginatedInput;
  Float: ResolverTypeWrapper<Scalars['Float']>;
  FloatNullableFilter: FloatNullableFilter;
  Gender: Gender;
  ID: ResolverTypeWrapper<Scalars['ID']>;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  IntNullableFilter: IntNullableFilter;
  JSON: ResolverTypeWrapper<Scalars['JSON']>;
  JSONObject: ResolverTypeWrapper<Scalars['JSONObject']>;
  JsonNullableFilter: JsonNullableFilter;
  JsonNullableListFilter: JsonNullableListFilter;
  JwtDecoded: ResolverTypeWrapper<JwtDecoded>;
  JwtHeaders: ResolverTypeWrapper<JwtHeaders>;
  JwtPayload: ResolverTypeWrapper<JwtPayload>;
  LoginInput: LoginInput;
  MediaItem: ResolverTypeWrapper<MediaItem>;
  MediaItemConnection: ResolverTypeWrapper<MediaItemConnection>;
  MediaItemCreateManyUserInput: MediaItemCreateManyUserInput;
  MediaItemCreateManyUserInputEnvelope: MediaItemCreateManyUserInputEnvelope;
  MediaItemCreateNestedManyWithoutUserInput: MediaItemCreateNestedManyWithoutUserInput;
  MediaItemCreateOrConnectWithoutUserInput: MediaItemCreateOrConnectWithoutUserInput;
  MediaItemCreateWithoutUserInput: MediaItemCreateWithoutUserInput;
  MediaItemDestination: MediaItemDestination;
  MediaItemEdge: ResolverTypeWrapper<MediaItemEdge>;
  MediaItemListRelationFilter: MediaItemListRelationFilter;
  MediaItemNameUserIdCompoundUniqueInput: MediaItemNameUserIdCompoundUniqueInput;
  MediaItemOrderByRelationAggregateInput: MediaItemOrderByRelationAggregateInput;
  MediaItemOrderByRelevanceFieldEnum: MediaItemOrderByRelevanceFieldEnum;
  MediaItemOrderByRelevanceInput: MediaItemOrderByRelevanceInput;
  MediaItemOrderByWithRelationAndSearchRelevanceInput: MediaItemOrderByWithRelationAndSearchRelevanceInput;
  MediaItemScalarFieldEnum: MediaItemScalarFieldEnum;
  MediaItemWhereInput: MediaItemWhereInput;
  MediaItemWhereUniqueInput: MediaItemWhereUniqueInput;
  MimeTypes: MimeTypes;
  Mutation: ResolverTypeWrapper<{}>;
  NestedBoolFilter: NestedBoolFilter;
  NestedDateTimeFilter: NestedDateTimeFilter;
  NestedDateTimeNullableFilter: NestedDateTimeNullableFilter;
  NestedEnumGenderNullableFilter: NestedEnumGenderNullableFilter;
  NestedEnumMediaItemDestinationNullableFilter: NestedEnumMediaItemDestinationNullableFilter;
  NestedEnumMimeTypesNullableFilter: NestedEnumMimeTypesNullableFilter;
  NestedEnumPronounsNullableFilter: NestedEnumPronounsNullableFilter;
  NestedEnumRoleNullableFilter: NestedEnumRoleNullableFilter;
  NestedEnumUserStatusNullableFilter: NestedEnumUserStatusNullableFilter;
  NestedFloatNullableFilter: NestedFloatNullableFilter;
  NestedIntNullableFilter: NestedIntNullableFilter;
  NestedStringFilter: NestedStringFilter;
  NestedStringNullableFilter: NestedStringNullableFilter;
  Node: never;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  PaginationArgsInput: PaginationArgsInput;
  PhoneNumber: ResolverTypeWrapper<Scalars['PhoneNumber']>;
  Profile: ResolverTypeWrapper<Profile>;
  ProfileConnection: ResolverTypeWrapper<ProfileConnection>;
  ProfileCreateInput: ProfileCreateInput;
  ProfileCreateNestedOneWithoutUserInput: ProfileCreateNestedOneWithoutUserInput;
  ProfileCreateOrConnectWithoutUserInput: ProfileCreateOrConnectWithoutUserInput;
  ProfileCreateWithoutUserInput: ProfileCreateWithoutUserInput;
  ProfileCreateactiviyFeedInput: ProfileCreateactiviyFeedInput;
  ProfileCreatebioInput: ProfileCreatebioInput;
  ProfileCreatecoverPhotoInput: ProfileCreatecoverPhotoInput;
  ProfileCreaterecentActivityInput: ProfileCreaterecentActivityInput;
  ProfileEdge: ResolverTypeWrapper<ProfileEdge>;
  ProfileOrderByRelevanceFieldEnum: ProfileOrderByRelevanceFieldEnum;
  ProfileOrderByRelevanceInput: ProfileOrderByRelevanceInput;
  ProfileOrderByWithRelationAndSearchRelevanceInput: ProfileOrderByWithRelationAndSearchRelevanceInput;
  ProfileRelationFilter: ProfileRelationFilter;
  ProfileScalarFieldEnum: ProfileScalarFieldEnum;
  ProfileWhereInput: ProfileWhereInput;
  ProfileWhereUniqueInput: ProfileWhereUniqueInput;
  ProfilesInput: ProfilesInput;
  Pronouns: Pronouns;
  Query: ResolverTypeWrapper<{}>;
  QueryMode: QueryMode;
  Role: Role;
  Session: ResolverTypeWrapper<Session>;
  SessionCreateManyUserInput: SessionCreateManyUserInput;
  SessionCreateManyUserInputEnvelope: SessionCreateManyUserInputEnvelope;
  SessionCreateManyscopesInput: SessionCreateManyscopesInput;
  SessionCreateNestedManyWithoutUserInput: SessionCreateNestedManyWithoutUserInput;
  SessionCreateOrConnectWithoutUserInput: SessionCreateOrConnectWithoutUserInput;
  SessionCreateWithoutUserInput: SessionCreateWithoutUserInput;
  SessionCreatescopesInput: SessionCreatescopesInput;
  SessionListRelationFilter: SessionListRelationFilter;
  SessionOrderByRelationAggregateInput: SessionOrderByRelationAggregateInput;
  SessionWhereInput: SessionWhereInput;
  SessionWhereUniqueInput: SessionWhereUniqueInput;
  SignupInput: SignupInput;
  SortOrder: SortOrder;
  String: ResolverTypeWrapper<Scalars['String']>;
  StringFilter: StringFilter;
  StringNullableFilter: StringNullableFilter;
  StringNullableListFilter: StringNullableListFilter;
  Subscription: ResolverTypeWrapper<{}>;
  Token: ResolverTypeWrapper<Token>;
  TypesUnion: ResolversTypes['Entry'] | ResolversTypes['MediaItem'] | ResolversTypes['User'];
  User: ResolverTypeWrapper<User>;
  UserConnection: ResolverTypeWrapper<UserConnection>;
  UserCount: ResolverTypeWrapper<UserCount>;
  UserCreateMutationInput: UserCreateMutationInput;
  UserCreateNestedOneWithoutCategoriesInput: UserCreateNestedOneWithoutCategoriesInput;
  UserCreateNestedOneWithoutCommentsInput: UserCreateNestedOneWithoutCommentsInput;
  UserCreateNestedOneWithoutEntriesInput: UserCreateNestedOneWithoutEntriesInput;
  UserCreateNestedOneWithoutProfileInput: UserCreateNestedOneWithoutProfileInput;
  UserCreateOrConnectWithoutCategoriesInput: UserCreateOrConnectWithoutCategoriesInput;
  UserCreateOrConnectWithoutCommentsInput: UserCreateOrConnectWithoutCommentsInput;
  UserCreateOrConnectWithoutEntriesInput: UserCreateOrConnectWithoutEntriesInput;
  UserCreateOrConnectWithoutProfileInput: UserCreateOrConnectWithoutProfileInput;
  UserCreateWithoutCategoriesInput: UserCreateWithoutCategoriesInput;
  UserCreateWithoutCommentsInput: UserCreateWithoutCommentsInput;
  UserCreateWithoutEntriesInput: UserCreateWithoutEntriesInput;
  UserCreateWithoutProfileInput: UserCreateWithoutProfileInput;
  UserCreateimageInput: UserCreateimageInput;
  UserEdge: ResolverTypeWrapper<UserEdge>;
  UserOrderByRelevanceFieldEnum: UserOrderByRelevanceFieldEnum;
  UserOrderByRelevanceInput: UserOrderByRelevanceInput;
  UserOrderByWithRelationAndSearchRelevanceInput: UserOrderByWithRelationAndSearchRelevanceInput;
  UserRelationFilter: UserRelationFilter;
  UserScalarFieldEnum: UserScalarFieldEnum;
  UserStatus: UserStatus;
  UserWhereInput: UserWhereInput;
  UserWhereUniqueInput: UserWhereUniqueInput;
  ViewerDetailed: ResolverTypeWrapper<ViewerDetailed>;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  Account: Account;
  AccountCreateManyUserInput: AccountCreateManyUserInput;
  AccountCreateManyUserInputEnvelope: AccountCreateManyUserInputEnvelope;
  AccountCreateNestedManyWithoutUserInput: AccountCreateNestedManyWithoutUserInput;
  AccountCreateOrConnectWithoutUserInput: AccountCreateOrConnectWithoutUserInput;
  AccountCreateWithoutUserInput: AccountCreateWithoutUserInput;
  AccountListRelationFilter: AccountListRelationFilter;
  AccountOrderByRelationAggregateInput: AccountOrderByRelationAggregateInput;
  AccountProviderProviderAccountIdCompoundUniqueInput: AccountProviderProviderAccountIdCompoundUniqueInput;
  AccountWhereInput: AccountWhereInput;
  AccountWhereUniqueInput: AccountWhereUniqueInput;
  Auth: Auth;
  AuthDetailed: AuthDetailed;
  AuthSansSession: AuthSansSession;
  BaseTypeNodes: Omit<BaseTypeNodes, 'nodes'> & { nodes: Array<ResolversParentTypes['TypesUnion']> };
  BaseTypesEdge: Omit<BaseTypesEdge, 'node'> & { node: ResolversParentTypes['TypesUnion'] };
  BigInt: Scalars['BigInt'];
  BoolFilter: BoolFilter;
  Boolean: Scalars['Boolean'];
  Category: Category;
  CategoryCount: CategoryCount;
  CategoryCreateManyCreatorInput: CategoryCreateManyCreatorInput;
  CategoryCreateManyCreatorInputEnvelope: CategoryCreateManyCreatorInputEnvelope;
  CategoryCreateNestedManyWithoutCreatorInput: CategoryCreateNestedManyWithoutCreatorInput;
  CategoryCreateNestedManyWithoutEntriesInput: CategoryCreateNestedManyWithoutEntriesInput;
  CategoryCreateOrConnectWithoutCreatorInput: CategoryCreateOrConnectWithoutCreatorInput;
  CategoryCreateOrConnectWithoutEntriesInput: CategoryCreateOrConnectWithoutEntriesInput;
  CategoryCreateWithoutCreatorInput: CategoryCreateWithoutCreatorInput;
  CategoryCreateWithoutEntriesInput: CategoryCreateWithoutEntriesInput;
  CategoryListRelationFilter: CategoryListRelationFilter;
  CategoryOrderByRelationAggregateInput: CategoryOrderByRelationAggregateInput;
  CategoryWhereInput: CategoryWhereInput;
  CategoryWhereUniqueInput: CategoryWhereUniqueInput;
  ChangePasswordInput: ChangePasswordInput;
  Comment: Comment;
  CommentAuthorIdEntryIdCompoundUniqueInput: CommentAuthorIdEntryIdCompoundUniqueInput;
  CommentCreateManyAuthorInput: CommentCreateManyAuthorInput;
  CommentCreateManyAuthorInputEnvelope: CommentCreateManyAuthorInputEnvelope;
  CommentCreateManyEntryInput: CommentCreateManyEntryInput;
  CommentCreateManyEntryInputEnvelope: CommentCreateManyEntryInputEnvelope;
  CommentCreateManyreactionsInput: CommentCreateManyreactionsInput;
  CommentCreateNestedManyWithoutAuthorInput: CommentCreateNestedManyWithoutAuthorInput;
  CommentCreateNestedManyWithoutEntryInput: CommentCreateNestedManyWithoutEntryInput;
  CommentCreateOrConnectWithoutAuthorInput: CommentCreateOrConnectWithoutAuthorInput;
  CommentCreateOrConnectWithoutEntryInput: CommentCreateOrConnectWithoutEntryInput;
  CommentCreateWithoutAuthorInput: CommentCreateWithoutAuthorInput;
  CommentCreateWithoutEntryInput: CommentCreateWithoutEntryInput;
  CommentCreatereactionsInput: CommentCreatereactionsInput;
  CommentListRelationFilter: CommentListRelationFilter;
  CommentOrderByRelationAggregateInput: CommentOrderByRelationAggregateInput;
  CommentWhereInput: CommentWhereInput;
  CommentWhereUniqueInput: CommentWhereUniqueInput;
  Connection: Connection;
  ConnectionCreateManyOwnerInput: ConnectionCreateManyOwnerInput;
  ConnectionCreateManyOwnerInputEnvelope: ConnectionCreateManyOwnerInputEnvelope;
  ConnectionCreateNestedManyWithoutOwnerInput: ConnectionCreateNestedManyWithoutOwnerInput;
  ConnectionCreateOrConnectWithoutOwnerInput: ConnectionCreateOrConnectWithoutOwnerInput;
  ConnectionCreateWithoutOwnerInput: ConnectionCreateWithoutOwnerInput;
  ConnectionListRelationFilter: ConnectionListRelationFilter;
  ConnectionOrderByRelationAggregateInput: ConnectionOrderByRelationAggregateInput;
  ConnectionWhereInput: ConnectionWhereInput;
  ConnectionWhereUniqueInput: ConnectionWhereUniqueInput;
  ContentNodes: ContentNodes;
  DateTime: Scalars['DateTime'];
  DateTimeFilter: DateTimeFilter;
  DateTimeNullableFilter: DateTimeNullableFilter;
  Entry: Entry;
  EntryConnection: EntryConnection;
  EntryCount: EntryCount;
  EntryCreateInput: EntryCreateInput;
  EntryCreateManyAuthorInput: EntryCreateManyAuthorInput;
  EntryCreateManyAuthorInputEnvelope: EntryCreateManyAuthorInputEnvelope;
  EntryCreateManycontentInput: EntryCreateManycontentInput;
  EntryCreateManyfeaturedImageInput: EntryCreateManyfeaturedImageInput;
  EntryCreateNestedManyWithoutAuthorInput: EntryCreateNestedManyWithoutAuthorInput;
  EntryCreateNestedManyWithoutCategoriesInput: EntryCreateNestedManyWithoutCategoriesInput;
  EntryCreateNestedOneWithoutCommentsInput: EntryCreateNestedOneWithoutCommentsInput;
  EntryCreateOrConnectWithoutAuthorInput: EntryCreateOrConnectWithoutAuthorInput;
  EntryCreateOrConnectWithoutCategoriesInput: EntryCreateOrConnectWithoutCategoriesInput;
  EntryCreateOrConnectWithoutCommentsInput: EntryCreateOrConnectWithoutCommentsInput;
  EntryCreateWithoutAuthorInput: EntryCreateWithoutAuthorInput;
  EntryCreateWithoutCategoriesInput: EntryCreateWithoutCategoriesInput;
  EntryCreateWithoutCommentsInput: EntryCreateWithoutCommentsInput;
  EntryCreatecontentInput: EntryCreatecontentInput;
  EntryCreatefeaturedImageInput: EntryCreatefeaturedImageInput;
  EntryEdge: EntryEdge;
  EntryListRelationFilter: EntryListRelationFilter;
  EntryOrderByRelationAggregateInput: EntryOrderByRelationAggregateInput;
  EntryOrderByRelevanceInput: EntryOrderByRelevanceInput;
  EntryOrderByWithRelationAndSearchRelevanceInput: EntryOrderByWithRelationAndSearchRelevanceInput;
  EntryRelationFilter: EntryRelationFilter;
  EntryWhereInput: EntryWhereInput;
  EntryWhereUniqueInput: EntryWhereUniqueInput;
  EnumCommentReactionsNullableListFilter: EnumCommentReactionsNullableListFilter;
  EnumGenderNullableFilter: EnumGenderNullableFilter;
  EnumMediaItemDestinationNullableFilter: EnumMediaItemDestinationNullableFilter;
  EnumMimeTypesNullableFilter: EnumMimeTypesNullableFilter;
  EnumPronounsNullableFilter: EnumPronounsNullableFilter;
  EnumRoleNullableFilter: EnumRoleNullableFilter;
  EnumUserStatusNullableFilter: EnumUserStatusNullableFilter;
  FindManyEntriessPaginatedInput: FindManyEntriessPaginatedInput;
  FindManyMediaItemsInput: FindManyMediaItemsInput;
  FindManyProfilesPaginatedInput: FindManyProfilesPaginatedInput;
  FindManyUsersPaginatedInput: FindManyUsersPaginatedInput;
  Float: Scalars['Float'];
  FloatNullableFilter: FloatNullableFilter;
  ID: Scalars['ID'];
  Int: Scalars['Int'];
  IntNullableFilter: IntNullableFilter;
  JSON: Scalars['JSON'];
  JSONObject: Scalars['JSONObject'];
  JsonNullableFilter: JsonNullableFilter;
  JsonNullableListFilter: JsonNullableListFilter;
  JwtDecoded: JwtDecoded;
  JwtHeaders: JwtHeaders;
  JwtPayload: JwtPayload;
  LoginInput: LoginInput;
  MediaItem: MediaItem;
  MediaItemConnection: MediaItemConnection;
  MediaItemCreateManyUserInput: MediaItemCreateManyUserInput;
  MediaItemCreateManyUserInputEnvelope: MediaItemCreateManyUserInputEnvelope;
  MediaItemCreateNestedManyWithoutUserInput: MediaItemCreateNestedManyWithoutUserInput;
  MediaItemCreateOrConnectWithoutUserInput: MediaItemCreateOrConnectWithoutUserInput;
  MediaItemCreateWithoutUserInput: MediaItemCreateWithoutUserInput;
  MediaItemEdge: MediaItemEdge;
  MediaItemListRelationFilter: MediaItemListRelationFilter;
  MediaItemNameUserIdCompoundUniqueInput: MediaItemNameUserIdCompoundUniqueInput;
  MediaItemOrderByRelationAggregateInput: MediaItemOrderByRelationAggregateInput;
  MediaItemOrderByRelevanceInput: MediaItemOrderByRelevanceInput;
  MediaItemOrderByWithRelationAndSearchRelevanceInput: MediaItemOrderByWithRelationAndSearchRelevanceInput;
  MediaItemWhereInput: MediaItemWhereInput;
  MediaItemWhereUniqueInput: MediaItemWhereUniqueInput;
  Mutation: {};
  NestedBoolFilter: NestedBoolFilter;
  NestedDateTimeFilter: NestedDateTimeFilter;
  NestedDateTimeNullableFilter: NestedDateTimeNullableFilter;
  NestedEnumGenderNullableFilter: NestedEnumGenderNullableFilter;
  NestedEnumMediaItemDestinationNullableFilter: NestedEnumMediaItemDestinationNullableFilter;
  NestedEnumMimeTypesNullableFilter: NestedEnumMimeTypesNullableFilter;
  NestedEnumPronounsNullableFilter: NestedEnumPronounsNullableFilter;
  NestedEnumRoleNullableFilter: NestedEnumRoleNullableFilter;
  NestedEnumUserStatusNullableFilter: NestedEnumUserStatusNullableFilter;
  NestedFloatNullableFilter: NestedFloatNullableFilter;
  NestedIntNullableFilter: NestedIntNullableFilter;
  NestedStringFilter: NestedStringFilter;
  NestedStringNullableFilter: NestedStringNullableFilter;
  Node: never;
  PageInfo: PageInfo;
  PaginationArgsInput: PaginationArgsInput;
  PhoneNumber: Scalars['PhoneNumber'];
  Profile: Profile;
  ProfileConnection: ProfileConnection;
  ProfileCreateInput: ProfileCreateInput;
  ProfileCreateNestedOneWithoutUserInput: ProfileCreateNestedOneWithoutUserInput;
  ProfileCreateOrConnectWithoutUserInput: ProfileCreateOrConnectWithoutUserInput;
  ProfileCreateWithoutUserInput: ProfileCreateWithoutUserInput;
  ProfileCreateactiviyFeedInput: ProfileCreateactiviyFeedInput;
  ProfileCreatebioInput: ProfileCreatebioInput;
  ProfileCreatecoverPhotoInput: ProfileCreatecoverPhotoInput;
  ProfileCreaterecentActivityInput: ProfileCreaterecentActivityInput;
  ProfileEdge: ProfileEdge;
  ProfileOrderByRelevanceInput: ProfileOrderByRelevanceInput;
  ProfileOrderByWithRelationAndSearchRelevanceInput: ProfileOrderByWithRelationAndSearchRelevanceInput;
  ProfileRelationFilter: ProfileRelationFilter;
  ProfileWhereInput: ProfileWhereInput;
  ProfileWhereUniqueInput: ProfileWhereUniqueInput;
  ProfilesInput: ProfilesInput;
  Query: {};
  Session: Session;
  SessionCreateManyUserInput: SessionCreateManyUserInput;
  SessionCreateManyUserInputEnvelope: SessionCreateManyUserInputEnvelope;
  SessionCreateManyscopesInput: SessionCreateManyscopesInput;
  SessionCreateNestedManyWithoutUserInput: SessionCreateNestedManyWithoutUserInput;
  SessionCreateOrConnectWithoutUserInput: SessionCreateOrConnectWithoutUserInput;
  SessionCreateWithoutUserInput: SessionCreateWithoutUserInput;
  SessionCreatescopesInput: SessionCreatescopesInput;
  SessionListRelationFilter: SessionListRelationFilter;
  SessionOrderByRelationAggregateInput: SessionOrderByRelationAggregateInput;
  SessionWhereInput: SessionWhereInput;
  SessionWhereUniqueInput: SessionWhereUniqueInput;
  SignupInput: SignupInput;
  String: Scalars['String'];
  StringFilter: StringFilter;
  StringNullableFilter: StringNullableFilter;
  StringNullableListFilter: StringNullableListFilter;
  Subscription: {};
  Token: Token;
  TypesUnion: ResolversParentTypes['Entry'] | ResolversParentTypes['MediaItem'] | ResolversParentTypes['User'];
  User: User;
  UserConnection: UserConnection;
  UserCount: UserCount;
  UserCreateMutationInput: UserCreateMutationInput;
  UserCreateNestedOneWithoutCategoriesInput: UserCreateNestedOneWithoutCategoriesInput;
  UserCreateNestedOneWithoutCommentsInput: UserCreateNestedOneWithoutCommentsInput;
  UserCreateNestedOneWithoutEntriesInput: UserCreateNestedOneWithoutEntriesInput;
  UserCreateNestedOneWithoutProfileInput: UserCreateNestedOneWithoutProfileInput;
  UserCreateOrConnectWithoutCategoriesInput: UserCreateOrConnectWithoutCategoriesInput;
  UserCreateOrConnectWithoutCommentsInput: UserCreateOrConnectWithoutCommentsInput;
  UserCreateOrConnectWithoutEntriesInput: UserCreateOrConnectWithoutEntriesInput;
  UserCreateOrConnectWithoutProfileInput: UserCreateOrConnectWithoutProfileInput;
  UserCreateWithoutCategoriesInput: UserCreateWithoutCategoriesInput;
  UserCreateWithoutCommentsInput: UserCreateWithoutCommentsInput;
  UserCreateWithoutEntriesInput: UserCreateWithoutEntriesInput;
  UserCreateWithoutProfileInput: UserCreateWithoutProfileInput;
  UserCreateimageInput: UserCreateimageInput;
  UserEdge: UserEdge;
  UserOrderByRelevanceInput: UserOrderByRelevanceInput;
  UserOrderByWithRelationAndSearchRelevanceInput: UserOrderByWithRelationAndSearchRelevanceInput;
  UserRelationFilter: UserRelationFilter;
  UserWhereInput: UserWhereInput;
  UserWhereUniqueInput: UserWhereUniqueInput;
  ViewerDetailed: ViewerDetailed;
}>;

export type AccountResolvers<ContextType = any, ParentType extends ResolversParentTypes['Account'] = ResolversParentTypes['Account']> = ResolversObject<{
  access_token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expires_at?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id_token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauth_token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauth_token_secret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  provider?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  providerAccountId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  refresh_secret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  refresh_token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  scope?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  session_state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  token_type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthResolvers<ContextType = any, ParentType extends ResolversParentTypes['Auth'] = ResolversParentTypes['Auth']> = ResolversObject<{
  accessToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  refreshToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  session?: Resolver<Maybe<ResolversTypes['Session']>, ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthDetailedResolvers<ContextType = any, ParentType extends ResolversParentTypes['AuthDetailed'] = ResolversParentTypes['AuthDetailed']> = ResolversObject<{
  auth?: Resolver<Maybe<ResolversTypes['Auth']>, ParentType, ContextType>;
  jwt?: Resolver<Maybe<ResolversTypes['JwtDecoded']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthSansSessionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AuthSansSession'] = ResolversParentTypes['AuthSansSession']> = ResolversObject<{
  accessToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  refreshToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BaseTypeNodesResolvers<ContextType = any, ParentType extends ResolversParentTypes['BaseTypeNodes'] = ResolversParentTypes['BaseTypeNodes']> = ResolversObject<{
  nodes?: Resolver<Array<ResolversTypes['TypesUnion']>, ParentType, ContextType>;
  pageInfo?: Resolver<Maybe<ResolversTypes['PageInfo']>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type BaseTypesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['BaseTypesEdge'] = ResolversParentTypes['BaseTypesEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['TypesUnion'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
  name: 'BigInt';
}

export type CategoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Category'] = ResolversParentTypes['Category']> = ResolversObject<{
  _count?: Resolver<ResolversTypes['CategoryCount'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  creator?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  creatorId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  entries?: Resolver<Maybe<Array<ResolversTypes['Entry']>>, ParentType, ContextType>;
  entryId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CategoryCountResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryCount'] = ResolversParentTypes['CategoryCount']> = ResolversObject<{
  entries?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type CommentResolvers<ContextType = any, ParentType extends ResolversParentTypes['Comment'] = ResolversParentTypes['Comment']> = ResolversObject<{
  author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  authorId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  body?: Resolver<Maybe<ResolversTypes['JSONObject']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  entry?: Resolver<ResolversTypes['Entry'], ParentType, ContextType>;
  entryId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reactions?: Resolver<Maybe<Array<ResolversTypes['CommentReactions']>>, ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Connection'] = ResolversParentTypes['Connection']> = ResolversObject<{
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ip?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  ownerId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  phoneNumber?: Resolver<Maybe<ResolversTypes['PhoneNumber']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ContentNodesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContentNodes'] = ResolversParentTypes['ContentNodes']> = ResolversObject<{
  contentNodes?: Resolver<ResolversTypes['BaseTypeNodes'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
  name: 'DateTime';
}

export type EntryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Entry'] = ResolversParentTypes['Entry']> = ResolversObject<{
  _count?: Resolver<ResolversTypes['EntryCount'], ParentType, ContextType>;
  author?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  authorId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  categories?: Resolver<Maybe<Array<ResolversTypes['Category']>>, ParentType, ContextType>;
  categoryId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comments?: Resolver<Maybe<Array<ResolversTypes['Comment']>>, ParentType, ContextType>;
  content?: Resolver<Maybe<Array<ResolversTypes['JSONObject']>>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  featuredImage?: Resolver<Maybe<Array<ResolversTypes['JSONObject']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  published?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EntryConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntryConnection'] = ResolversParentTypes['EntryConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['EntryEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EntryCountResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntryCount'] = ResolversParentTypes['EntryCount']> = ResolversObject<{
  categories?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EntryEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntryEdge'] = ResolversParentTypes['EntryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Entry'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
  name: 'JSON';
}

export interface JsonObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSONObject'], any> {
  name: 'JSONObject';
}

export type JwtDecodedResolvers<ContextType = any, ParentType extends ResolversParentTypes['JwtDecoded'] = ResolversParentTypes['JwtDecoded']> = ResolversObject<{
  header?: Resolver<ResolversTypes['JwtHeaders'], ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['JwtPayload'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type JwtHeadersResolvers<ContextType = any, ParentType extends ResolversParentTypes['JwtHeaders'] = ResolversParentTypes['JwtHeaders']> = ResolversObject<{
  alg?: Resolver<ResolversTypes['AlgorithmType'], ParentType, ContextType>;
  typ?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type JwtPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['JwtPayload'] = ResolversParentTypes['JwtPayload']> = ResolversObject<{
  exp?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  iat?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MediaItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['MediaItem'] = ResolversParentTypes['MediaItem']> = ResolversObject<{
  fileLastModified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  height?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quality?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  src?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  srcSet?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['MimeTypes']>, ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  uploadedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  width?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MediaItemConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MediaItemConnection'] = ResolversParentTypes['MediaItemConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['MediaItemEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MediaItemEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MediaItemEdge'] = ResolversParentTypes['MediaItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['MediaItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = ResolversObject<{
  changePassword?: Resolver<ResolversTypes['User'], ParentType, ContextType, RequireFields<MutationChangePasswordArgs, 'changePasswordInput'>>;
  createEntry?: Resolver<ResolversTypes['Entry'], ParentType, ContextType, RequireFields<MutationCreateEntryArgs, 'createInput'>>;
  createProfile?: Resolver<ResolversTypes['Profile'], ParentType, ContextType, RequireFields<MutationCreateProfileArgs, 'data' | 'userId'>>;
  getUserFromAccessToken?: Resolver<ResolversTypes['User'], ParentType, ContextType, RequireFields<MutationGetUserFromAccessTokenArgs, 'token'>>;
  getViewerRefreshToken?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['Token'], ParentType, ContextType, RequireFields<MutationLoginArgs, 'data'>>;
  register?: Resolver<ResolversTypes['AuthSansSession'], ParentType, ContextType, RequireFields<MutationRegisterArgs, 'dataRegister'>>;
  registerNewUser?: Resolver<ResolversTypes['AuthDetailed'], ParentType, ContextType, RequireFields<MutationRegisterNewUserArgs, 'userCreateInput'>>;
  signin?: Resolver<ResolversTypes['AuthDetailed'], ParentType, ContextType, RequireFields<MutationSigninArgs, 'userloginInput'>>;
  signup?: Resolver<ResolversTypes['Token'], ParentType, ContextType, RequireFields<MutationSignupArgs, 'data'>>;
  updateUserPassword?: Resolver<ResolversTypes['User'], ParentType, ContextType, RequireFields<MutationUpdateUserPasswordArgs, 'passwordInput'>>;
  userFromAccessTokenDecoded?: Resolver<ResolversTypes['AuthDetailed'], ParentType, ContextType, RequireFields<MutationUserFromAccessTokenDecodedArgs, 'token'>>;
}>;

export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = ResolversObject<{
  __resolveType: TypeResolveFn<null, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
}>;

export type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = ResolversObject<{
  endCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface PhoneNumberScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['PhoneNumber'], any> {
  name: 'PhoneNumber';
}

export type ProfileResolvers<ContextType = any, ParentType extends ResolversParentTypes['Profile'] = ResolversParentTypes['Profile']> = ResolversObject<{
  activiyFeed?: Resolver<Maybe<Array<ResolversTypes['JSONObject']>>, ParentType, ContextType>;
  bio?: Resolver<Maybe<Array<ResolversTypes['JSONObject']>>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  coverPhoto?: Resolver<Maybe<Array<ResolversTypes['JSONObject']>>, ParentType, ContextType>;
  dob?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gender?: Resolver<Maybe<ResolversTypes['Gender']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastSeen?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  memberSince?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  occupation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  phoneNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pronouns?: Resolver<Maybe<ResolversTypes['Pronouns']>, ParentType, ContextType>;
  recentActivity?: Resolver<Maybe<Array<ResolversTypes['JSONObject']>>, ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  userInProfile?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProfileConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProfileConnection'] = ResolversParentTypes['ProfileConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['ProfileEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ProfileEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProfileEdge'] = ResolversParentTypes['ProfileEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Profile'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = ResolversObject<{
  contentNodesUnion?: Resolver<ResolversTypes['ContentNodes'], ParentType, ContextType, RequireFields<QueryContentNodesUnionArgs, 'findManyEntriesPaginatedInput'>>;
  entryById?: Resolver<ResolversTypes['Entry'], ParentType, ContextType, RequireFields<QueryEntryByIdArgs, 'id'>>;
  findUniqueMediaItem?: Resolver<ResolversTypes['MediaItem'], ParentType, ContextType, RequireFields<QueryFindUniqueMediaItemArgs, 'mediaItemId'>>;
  getViewer?: Resolver<ResolversTypes['AuthDetailed'], ParentType, ContextType>;
  hello?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<QueryHelloArgs, 'name'>>;
  helloWorld?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  listEntries?: Resolver<ResolversTypes['EntryConnection'], ParentType, ContextType, RequireFields<QueryListEntriesArgs, 'findManyEntriesPaginatedInput'>>;
  listMediaItems?: Resolver<ResolversTypes['MediaItemConnection'], ParentType, ContextType, Partial<QueryListMediaItemsArgs>>;
  listProfiles?: Resolver<ResolversTypes['ProfileConnection'], ParentType, ContextType, RequireFields<QueryListProfilesArgs, 'findManyProfilesPaginatedInput'>>;
  listUsers?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<QueryListUsersArgs, 'findManyUsersPaginatedInput'>>;
  me?: Resolver<ResolversTypes['AuthDetailed'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType, RequireFields<QueryNodeArgs, 'id'>>;
  profileByRelayId?: Resolver<ResolversTypes['Profile'], ParentType, ContextType>;
  profiles?: Resolver<ResolversTypes['ProfileConnection'], ParentType, ContextType, RequireFields<QueryProfilesArgs, 'profilesArgs'>>;
  userById?: Resolver<ResolversTypes['User'], ParentType, ContextType, RequireFields<QueryUserByIdArgs, 'id'>>;
  userByRelayId?: Resolver<ResolversTypes['User'], ParentType, ContextType, RequireFields<QueryUserByRelayIdArgs, 'cursor'>>;
  userPosts?: Resolver<Array<ResolversTypes['Entry']>, ParentType, ContextType, RequireFields<QueryUserPostsArgs, 'userId'>>;
  viewer?: Resolver<ResolversTypes['ViewerDetailed'], ParentType, ContextType>;
}>;

export type SessionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Session'] = ResolversParentTypes['Session']> = ResolversObject<{
  accessToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  alg?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  exp?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  iat?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastVerified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  provider?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  refreshToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  scopes?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  signature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tokenState?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = ResolversObject<{
  entryCreated?: SubscriptionResolver<ResolversTypes['Entry'], "entryCreated", ParentType, ContextType>;
  profileCreated?: SubscriptionResolver<ResolversTypes['Profile'], "profileCreated", ParentType, ContextType>;
}>;

export type TokenResolvers<ContextType = any, ParentType extends ResolversParentTypes['Token'] = ResolversParentTypes['Token']> = ResolversObject<{
  accessToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  refreshToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TypesUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TypesUnion'] = ResolversParentTypes['TypesUnion']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Entry' | 'MediaItem' | 'User', ParentType, ContextType>;
}>;

export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = ResolversObject<{
  _count?: Resolver<Maybe<ResolversTypes['UserCount']>, ParentType, ContextType>;
  accounts?: Resolver<Maybe<Array<ResolversTypes['Account']>>, ParentType, ContextType>;
  categories?: Resolver<Maybe<Array<ResolversTypes['Category']>>, ParentType, ContextType>;
  comments?: Resolver<Maybe<Array<ResolversTypes['Comment']>>, ParentType, ContextType>;
  connections?: Resolver<Maybe<Array<ResolversTypes['Connection']>>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  emailVerified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  entries?: Resolver<Maybe<Array<ResolversTypes['Entry']>>, ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  image?: Resolver<Array<ResolversTypes['JSONObject']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mediaItems?: Resolver<Maybe<Array<ResolversTypes['MediaItem']>>, ParentType, ContextType>;
  password?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  profile?: Resolver<Maybe<ResolversTypes['Profile']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType>;
  sessions?: Resolver<Maybe<Array<ResolversTypes['Session']>>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['UserStatus'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserConnection'] = ResolversParentTypes['UserConnection']> = ResolversObject<{
  edges?: Resolver<Array<ResolversTypes['UserEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserCountResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserCount'] = ResolversParentTypes['UserCount']> = ResolversObject<{
  accounts?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  categories?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  connections?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  entries?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  mediaItems?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  sessions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserEdge'] = ResolversParentTypes['UserEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ViewerDetailedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ViewerDetailed'] = ResolversParentTypes['ViewerDetailed']> = ResolversObject<{
  _count?: Resolver<Maybe<ResolversTypes['UserCount']>, ParentType, ContextType>;
  accessToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  accounts?: Resolver<Maybe<Array<ResolversTypes['Account']>>, ParentType, ContextType>;
  categories?: Resolver<Maybe<Array<ResolversTypes['Category']>>, ParentType, ContextType>;
  comments?: Resolver<Maybe<Array<ResolversTypes['Comment']>>, ParentType, ContextType>;
  connections?: Resolver<Maybe<Array<ResolversTypes['Connection']>>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  emailVerified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  entries?: Resolver<Maybe<Array<ResolversTypes['Entry']>>, ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  image?: Resolver<Array<ResolversTypes['JSONObject']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mediaItems?: Resolver<Maybe<Array<ResolversTypes['MediaItem']>>, ParentType, ContextType>;
  password?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  profile?: Resolver<Maybe<ResolversTypes['Profile']>, ParentType, ContextType>;
  refreshToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType>;
  secret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sessions?: Resolver<Maybe<Array<ResolversTypes['Session']>>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['UserStatus'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Resolvers<ContextType = any> = ResolversObject<{
  Account?: AccountResolvers<ContextType>;
  Auth?: AuthResolvers<ContextType>;
  AuthDetailed?: AuthDetailedResolvers<ContextType>;
  AuthSansSession?: AuthSansSessionResolvers<ContextType>;
  BaseTypeNodes?: BaseTypeNodesResolvers<ContextType>;
  BaseTypesEdge?: BaseTypesEdgeResolvers<ContextType>;
  BigInt?: GraphQLScalarType;
  Category?: CategoryResolvers<ContextType>;
  CategoryCount?: CategoryCountResolvers<ContextType>;
  Comment?: CommentResolvers<ContextType>;
  Connection?: ConnectionResolvers<ContextType>;
  ContentNodes?: ContentNodesResolvers<ContextType>;
  DateTime?: GraphQLScalarType;
  Entry?: EntryResolvers<ContextType>;
  EntryConnection?: EntryConnectionResolvers<ContextType>;
  EntryCount?: EntryCountResolvers<ContextType>;
  EntryEdge?: EntryEdgeResolvers<ContextType>;
  JSON?: GraphQLScalarType;
  JSONObject?: GraphQLScalarType;
  JwtDecoded?: JwtDecodedResolvers<ContextType>;
  JwtHeaders?: JwtHeadersResolvers<ContextType>;
  JwtPayload?: JwtPayloadResolvers<ContextType>;
  MediaItem?: MediaItemResolvers<ContextType>;
  MediaItemConnection?: MediaItemConnectionResolvers<ContextType>;
  MediaItemEdge?: MediaItemEdgeResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  PhoneNumber?: GraphQLScalarType;
  Profile?: ProfileResolvers<ContextType>;
  ProfileConnection?: ProfileConnectionResolvers<ContextType>;
  ProfileEdge?: ProfileEdgeResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  Session?: SessionResolvers<ContextType>;
  Subscription?: SubscriptionResolvers<ContextType>;
  Token?: TokenResolvers<ContextType>;
  TypesUnion?: TypesUnionResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserConnection?: UserConnectionResolvers<ContextType>;
  UserCount?: UserCountResolvers<ContextType>;
  UserEdge?: UserEdgeResolvers<ContextType>;
  ViewerDetailed?: ViewerDetailedResolvers<ContextType>;
}>;

