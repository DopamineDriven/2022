# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Account implements Node {
  access_token: String
  expires_at: Int
  id: ID!
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String!
  providerAccountId: String!
  refresh_secret: String
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  user: User!
  userId: String!
}

input AccountCreateManyUserInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String!
  providerAccountId: String!
  refresh_secret: String
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
}

input AccountCreateManyUserInputEnvelope {
  data: [AccountCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input AccountCreateNestedManyWithoutUserInput {
  connect: [AccountWhereUniqueInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  create: [AccountCreateWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
}

input AccountCreateOrConnectWithoutUserInput {
  create: AccountCreateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountCreateWithoutUserInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String!
  providerAccountId: String!
  refresh_secret: String
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
}

input AccountListRelationFilter {
  every: AccountWhereInput
  none: AccountWhereInput
  some: AccountWhereInput
}

input AccountOrderByRelationAggregateInput {
  _count: SortOrder
}

input AccountProviderProviderAccountIdCompoundUniqueInput {
  provider: String!
  providerAccountId: String!
}

input AccountScalarWhereInput {
  AND: [AccountScalarWhereInput!]
  NOT: [AccountScalarWhereInput!]
  OR: [AccountScalarWhereInput!]
  access_token: StringNullableFilter
  expires_at: IntNullableFilter
  id: StringFilter
  id_token: StringNullableFilter
  oauth_token: StringNullableFilter
  oauth_token_secret: StringNullableFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_secret: StringNullableFilter
  refresh_token: StringNullableFilter
  scope: StringNullableFilter
  session_state: StringNullableFilter
  token_type: StringNullableFilter
  type: StringFilter
  userId: StringFilter
}

input AccountUpdateManyMutationInput {
  access_token: NullableStringFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  oauth_token: NullableStringFieldUpdateOperationsInput
  oauth_token_secret: NullableStringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_secret: NullableStringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input AccountUpdateManyWithWhereWithoutUserInput {
  data: AccountUpdateManyMutationInput!
  where: AccountScalarWhereInput!
}

input AccountUpdateManyWithoutUserInput {
  connect: [AccountWhereUniqueInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  create: [AccountCreateWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
  delete: [AccountWhereUniqueInput!]
  deleteMany: [AccountScalarWhereInput!]
  disconnect: [AccountWhereUniqueInput!]
  set: [AccountWhereUniqueInput!]
  update: [AccountUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [AccountUpdateManyWithWhereWithoutUserInput!]
  upsert: [AccountUpsertWithWhereUniqueWithoutUserInput!]
}

input AccountUpdateWithWhereUniqueWithoutUserInput {
  data: AccountUpdateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountUpdateWithoutUserInput {
  access_token: NullableStringFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  oauth_token: NullableStringFieldUpdateOperationsInput
  oauth_token_secret: NullableStringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_secret: NullableStringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input AccountUpsertWithWhereUniqueWithoutUserInput {
  create: AccountCreateWithoutUserInput!
  update: AccountUpdateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  access_token: StringNullableFilter
  expires_at: IntNullableFilter
  id: StringFilter
  id_token: StringNullableFilter
  oauth_token: StringNullableFilter
  oauth_token_secret: StringNullableFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_secret: StringNullableFilter
  refresh_token: StringNullableFilter
  scope: StringNullableFilter
  session_state: StringNullableFilter
  token_type: StringNullableFilter
  type: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input AccountWhereUniqueInput {
  id: String
  provider_providerAccountId: AccountProviderProviderAccountIdCompoundUniqueInput
}

enum AlgorithmType {
  ES256
  ES256K
  ES384
  ES512
  Ed448
  Ed25519
  HS256
  HS384
  HS512
  None
  PS256
  PS384
  PS512
  RS256
  RS384
  RS512
}

type Auth {
  """JWT access token"""
  accessToken: String

  """JWT refresh token"""
  refreshToken: String
  session: Session
  user: User!
}

type AuthDetailed {
  auth: Auth
  jwt: JwtDecoded
}

type AuthSansSession {
  """JWT access token"""
  accessToken: String

  """JWT refresh token"""
  refreshToken: String
  user: User
}

type BaseTypeNodes {
  nodes: [TypesUnion!]!
  pageInfo: PageInfo
  totalCount: Int!
}

type BaseTypesEdge {
  cursor: String!
  node: TypesUnion!
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Category implements Node {
  _count: CategoryCount!
  createdAt: DateTime
  creator: User!
  creatorId: String!
  entries: [Entry!]
  entryId: String
  id: ID!
  name: String!
  updatedAt: DateTime
}

type CategoryCount {
  entries: Int!
}

input CategoryCreateManyCreatorInput {
  createdAt: DateTime
  entryId: String
  id: String
  name: String!
  updatedAt: DateTime
}

input CategoryCreateManyCreatorInputEnvelope {
  data: [CategoryCreateManyCreatorInput!]!
  skipDuplicates: Boolean
}

input CategoryCreateNestedManyWithoutCreatorInput {
  connect: [CategoryWhereUniqueInput!]
  connectOrCreate: [CategoryCreateOrConnectWithoutCreatorInput!]
  create: [CategoryCreateWithoutCreatorInput!]
  createMany: CategoryCreateManyCreatorInputEnvelope
}

input CategoryCreateNestedManyWithoutEntriesInput {
  connect: [CategoryWhereUniqueInput!]
  connectOrCreate: [CategoryCreateOrConnectWithoutEntriesInput!]
  create: [CategoryCreateWithoutEntriesInput!]
}

input CategoryCreateOrConnectWithoutCreatorInput {
  create: CategoryCreateWithoutCreatorInput!
  where: CategoryWhereUniqueInput!
}

input CategoryCreateOrConnectWithoutEntriesInput {
  create: CategoryCreateWithoutEntriesInput!
  where: CategoryWhereUniqueInput!
}

input CategoryCreateWithoutCreatorInput {
  createdAt: DateTime
  entries: EntryCreateNestedManyWithoutCategoriesInput
  entryId: String
  id: String
  name: String!
  updatedAt: DateTime
}

input CategoryCreateWithoutEntriesInput {
  createdAt: DateTime
  creator: UserCreateNestedOneWithoutCategoriesInput!
  entryId: String
  id: String
  name: String!
  updatedAt: DateTime
}

input CategoryListRelationFilter {
  every: CategoryWhereInput
  none: CategoryWhereInput
  some: CategoryWhereInput
}

input CategoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input CategoryScalarWhereInput {
  AND: [CategoryScalarWhereInput!]
  NOT: [CategoryScalarWhereInput!]
  OR: [CategoryScalarWhereInput!]
  createdAt: DateTimeNullableFilter
  creatorId: StringFilter
  entryId: StringNullableFilter
  id: StringFilter
  name: StringFilter
  updatedAt: DateTimeNullableFilter
}

input CategoryUpdateManyMutationInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  entryId: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input CategoryUpdateManyWithWhereWithoutCreatorInput {
  data: CategoryUpdateManyMutationInput!
  where: CategoryScalarWhereInput!
}

input CategoryUpdateManyWithWhereWithoutEntriesInput {
  data: CategoryUpdateManyMutationInput!
  where: CategoryScalarWhereInput!
}

input CategoryUpdateManyWithoutCreatorInput {
  connect: [CategoryWhereUniqueInput!]
  connectOrCreate: [CategoryCreateOrConnectWithoutCreatorInput!]
  create: [CategoryCreateWithoutCreatorInput!]
  createMany: CategoryCreateManyCreatorInputEnvelope
  delete: [CategoryWhereUniqueInput!]
  deleteMany: [CategoryScalarWhereInput!]
  disconnect: [CategoryWhereUniqueInput!]
  set: [CategoryWhereUniqueInput!]
  update: [CategoryUpdateWithWhereUniqueWithoutCreatorInput!]
  updateMany: [CategoryUpdateManyWithWhereWithoutCreatorInput!]
  upsert: [CategoryUpsertWithWhereUniqueWithoutCreatorInput!]
}

input CategoryUpdateManyWithoutEntriesInput {
  connect: [CategoryWhereUniqueInput!]
  connectOrCreate: [CategoryCreateOrConnectWithoutEntriesInput!]
  create: [CategoryCreateWithoutEntriesInput!]
  delete: [CategoryWhereUniqueInput!]
  deleteMany: [CategoryScalarWhereInput!]
  disconnect: [CategoryWhereUniqueInput!]
  set: [CategoryWhereUniqueInput!]
  update: [CategoryUpdateWithWhereUniqueWithoutEntriesInput!]
  updateMany: [CategoryUpdateManyWithWhereWithoutEntriesInput!]
  upsert: [CategoryUpsertWithWhereUniqueWithoutEntriesInput!]
}

input CategoryUpdateWithWhereUniqueWithoutCreatorInput {
  data: CategoryUpdateWithoutCreatorInput!
  where: CategoryWhereUniqueInput!
}

input CategoryUpdateWithWhereUniqueWithoutEntriesInput {
  data: CategoryUpdateWithoutEntriesInput!
  where: CategoryWhereUniqueInput!
}

input CategoryUpdateWithoutCreatorInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  entries: EntryUpdateManyWithoutCategoriesInput
  entryId: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input CategoryUpdateWithoutEntriesInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  creator: UserUpdateOneRequiredWithoutCategoriesInput
  entryId: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input CategoryUpsertWithWhereUniqueWithoutCreatorInput {
  create: CategoryCreateWithoutCreatorInput!
  update: CategoryUpdateWithoutCreatorInput!
  where: CategoryWhereUniqueInput!
}

input CategoryUpsertWithWhereUniqueWithoutEntriesInput {
  create: CategoryCreateWithoutEntriesInput!
  update: CategoryUpdateWithoutEntriesInput!
  where: CategoryWhereUniqueInput!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  createdAt: DateTimeNullableFilter
  creator: UserRelationFilter
  creatorId: StringFilter
  entries: EntryListRelationFilter
  entryId: StringNullableFilter
  id: StringFilter
  name: StringFilter
  updatedAt: DateTimeNullableFilter
}

input CategoryWhereUniqueInput {
  id: String
  name: String
}

input ChangePasswordInput {
  newPassword: String!
  oldPassword: String!
}

type Comment implements Node {
  author: User!
  authorId: String!
  body: String
  createdAt: DateTime!
  entry: Entry!
  entryId: String!
  id: ID!
  position: String
  reactions: [CommentReactions!]
  updatedAt: DateTime
}

input CommentAuthorIdEntryIdCompoundUniqueInput {
  authorId: String!
  entryId: String!
}

type CommentConnection {
  edges: [CommentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input CommentCreateManyAuthorInput {
  body: String
  createdAt: DateTime
  entryId: String!
  id: String
  position: String
  reactions: CommentCreateManyreactionsInput
  updatedAt: DateTime
}

input CommentCreateManyAuthorInputEnvelope {
  data: [CommentCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input CommentCreateManyEntryInput {
  authorId: String!
  body: String
  createdAt: DateTime
  id: String
  position: String
  reactions: CommentCreateManyreactionsInput
  updatedAt: DateTime
}

input CommentCreateManyEntryInputEnvelope {
  data: [CommentCreateManyEntryInput!]!
  skipDuplicates: Boolean
}

input CommentCreateManyreactionsInput {
  set: [CommentReactions!]!
}

input CommentCreateNestedManyWithoutAuthorInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutAuthorInput!]
  create: [CommentCreateWithoutAuthorInput!]
  createMany: CommentCreateManyAuthorInputEnvelope
}

input CommentCreateNestedManyWithoutEntryInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutEntryInput!]
  create: [CommentCreateWithoutEntryInput!]
  createMany: CommentCreateManyEntryInputEnvelope
}

input CommentCreateOrConnectWithoutAuthorInput {
  create: CommentCreateWithoutAuthorInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateOrConnectWithoutEntryInput {
  create: CommentCreateWithoutEntryInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateWithoutAuthorInput {
  body: String
  createdAt: DateTime
  entry: EntryCreateNestedOneWithoutCommentsInput!
  id: String
  position: String
  reactions: CommentCreatereactionsInput
  updatedAt: DateTime
}

input CommentCreateWithoutEntryInput {
  author: UserCreateNestedOneWithoutCommentsInput!
  body: String
  createdAt: DateTime
  id: String
  position: String
  reactions: CommentCreatereactionsInput
  updatedAt: DateTime
}

input CommentCreatereactionsInput {
  set: [CommentReactions!]!
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

input CommentListRelationFilter {
  every: CommentWhereInput
  none: CommentWhereInput
  some: CommentWhereInput
}

input CommentOrderByRelationAggregateInput {
  _count: SortOrder
}

enum CommentOrderByRelevanceFieldEnum {
  authorId
  body
  entryId
  id
  position
}

input CommentOrderByRelevanceInput {
  fields: [CommentOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input CommentOrderByWithRelationAndSearchRelevanceInput {
  _relevance: CommentOrderByRelevanceInput
  author: UserOrderByWithRelationAndSearchRelevanceInput
  authorId: SortOrder
  body: SortOrder
  createdAt: SortOrder
  entry: EntryOrderByWithRelationAndSearchRelevanceInput
  entryId: SortOrder
  id: SortOrder
  position: SortOrder
  reactions: SortOrder
  updatedAt: SortOrder
}

enum CommentReactions {
  ANGRY
  CARE
  CONFUSED
  DISLIKE
  LAUGH
  LIKE
  LOVE
  PARROT
  ROCKET
  TEARS
  WOW
}

enum CommentScalarFieldEnum {
  authorId
  body
  createdAt
  entryId
  id
  position
  reactions
  updatedAt
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  authorId: StringFilter
  body: StringNullableFilter
  createdAt: DateTimeFilter
  entryId: StringFilter
  id: StringFilter
  position: StringNullableFilter
  reactions: EnumCommentReactionsNullableListFilter
  updatedAt: DateTimeNullableFilter
}

input CommentUpdateManyMutationInput {
  body: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  position: NullableStringFieldUpdateOperationsInput
  reactions: CommentUpdatereactionsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input CommentUpdateManyWithWhereWithoutAuthorInput {
  data: CommentUpdateManyMutationInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithWhereWithoutEntryInput {
  data: CommentUpdateManyMutationInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithoutAuthorInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutAuthorInput!]
  create: [CommentCreateWithoutAuthorInput!]
  createMany: CommentCreateManyAuthorInputEnvelope
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutAuthorInput!]
}

input CommentUpdateManyWithoutEntryInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutEntryInput!]
  create: [CommentCreateWithoutEntryInput!]
  createMany: CommentCreateManyEntryInputEnvelope
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutEntryInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutEntryInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutEntryInput!]
}

input CommentUpdateWithWhereUniqueWithoutAuthorInput {
  data: CommentUpdateWithoutAuthorInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithWhereUniqueWithoutEntryInput {
  data: CommentUpdateWithoutEntryInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithoutAuthorInput {
  body: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  entry: EntryUpdateOneRequiredWithoutCommentsInput
  id: StringFieldUpdateOperationsInput
  position: NullableStringFieldUpdateOperationsInput
  reactions: CommentUpdatereactionsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input CommentUpdateWithoutEntryInput {
  author: UserUpdateOneRequiredWithoutCommentsInput
  body: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  position: NullableStringFieldUpdateOperationsInput
  reactions: CommentUpdatereactionsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input CommentUpdatereactionsInput {
  push: [CommentReactions!]
  set: [CommentReactions!]
}

input CommentUpsertWithWhereUniqueWithoutAuthorInput {
  create: CommentCreateWithoutAuthorInput!
  update: CommentUpdateWithoutAuthorInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutEntryInput {
  create: CommentCreateWithoutEntryInput!
  update: CommentUpdateWithoutEntryInput!
  where: CommentWhereUniqueInput!
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  author: UserRelationFilter
  authorId: StringFilter
  body: StringNullableFilter
  createdAt: DateTimeFilter
  entry: EntryRelationFilter
  entryId: StringFilter
  id: StringFilter
  position: StringNullableFilter
  reactions: EnumCommentReactionsNullableListFilter
  updatedAt: DateTimeNullableFilter
}

input CommentWhereUniqueInput {
  authorId_entryId: CommentAuthorIdEntryIdCompoundUniqueInput
  id: String
}

type Connection implements Node {
  email: String!
  firstName: String
  id: ID!
  ip: String
  lastModified: DateTime
  lastName: String
  owner: User!
  ownerId: String!
  phoneNumber: PhoneNumber
}

input ConnectionCreateManyOwnerInput {
  email: String!
  firstName: String
  id: String
  ip: String
  lastModified: DateTime
  lastName: String
  phoneNumber: String
}

input ConnectionCreateManyOwnerInputEnvelope {
  data: [ConnectionCreateManyOwnerInput!]!
  skipDuplicates: Boolean
}

input ConnectionCreateNestedManyWithoutOwnerInput {
  connect: [ConnectionWhereUniqueInput!]
  connectOrCreate: [ConnectionCreateOrConnectWithoutOwnerInput!]
  create: [ConnectionCreateWithoutOwnerInput!]
  createMany: ConnectionCreateManyOwnerInputEnvelope
}

input ConnectionCreateOrConnectWithoutOwnerInput {
  create: ConnectionCreateWithoutOwnerInput!
  where: ConnectionWhereUniqueInput!
}

input ConnectionCreateWithoutOwnerInput {
  email: String!
  firstName: String
  id: String
  ip: String
  lastModified: DateTime
  lastName: String
  phoneNumber: String
}

input ConnectionListRelationFilter {
  every: ConnectionWhereInput
  none: ConnectionWhereInput
  some: ConnectionWhereInput
}

input ConnectionOrderByRelationAggregateInput {
  _count: SortOrder
}

input ConnectionScalarWhereInput {
  AND: [ConnectionScalarWhereInput!]
  NOT: [ConnectionScalarWhereInput!]
  OR: [ConnectionScalarWhereInput!]
  email: StringFilter
  firstName: StringNullableFilter
  id: StringFilter
  ip: StringNullableFilter
  lastModified: DateTimeNullableFilter
  lastName: StringNullableFilter
  ownerId: StringFilter
  phoneNumber: StringNullableFilter
}

input ConnectionUpdateManyMutationInput {
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  ip: NullableStringFieldUpdateOperationsInput
  lastModified: NullableDateTimeFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  phoneNumber: NullableStringFieldUpdateOperationsInput
}

input ConnectionUpdateManyWithWhereWithoutOwnerInput {
  data: ConnectionUpdateManyMutationInput!
  where: ConnectionScalarWhereInput!
}

input ConnectionUpdateManyWithoutOwnerInput {
  connect: [ConnectionWhereUniqueInput!]
  connectOrCreate: [ConnectionCreateOrConnectWithoutOwnerInput!]
  create: [ConnectionCreateWithoutOwnerInput!]
  createMany: ConnectionCreateManyOwnerInputEnvelope
  delete: [ConnectionWhereUniqueInput!]
  deleteMany: [ConnectionScalarWhereInput!]
  disconnect: [ConnectionWhereUniqueInput!]
  set: [ConnectionWhereUniqueInput!]
  update: [ConnectionUpdateWithWhereUniqueWithoutOwnerInput!]
  updateMany: [ConnectionUpdateManyWithWhereWithoutOwnerInput!]
  upsert: [ConnectionUpsertWithWhereUniqueWithoutOwnerInput!]
}

input ConnectionUpdateWithWhereUniqueWithoutOwnerInput {
  data: ConnectionUpdateWithoutOwnerInput!
  where: ConnectionWhereUniqueInput!
}

input ConnectionUpdateWithoutOwnerInput {
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  ip: NullableStringFieldUpdateOperationsInput
  lastModified: NullableDateTimeFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  phoneNumber: NullableStringFieldUpdateOperationsInput
}

input ConnectionUpsertWithWhereUniqueWithoutOwnerInput {
  create: ConnectionCreateWithoutOwnerInput!
  update: ConnectionUpdateWithoutOwnerInput!
  where: ConnectionWhereUniqueInput!
}

input ConnectionWhereInput {
  AND: [ConnectionWhereInput!]
  NOT: [ConnectionWhereInput!]
  OR: [ConnectionWhereInput!]
  email: StringFilter
  firstName: StringNullableFilter
  id: StringFilter
  ip: StringNullableFilter
  lastModified: DateTimeNullableFilter
  lastName: StringNullableFilter
  owner: UserRelationFilter
  ownerId: StringFilter
  phoneNumber: StringNullableFilter
}

input ConnectionWhereUniqueInput {
  id: String
}

type ContentNodes {
  contentNodes: BaseTypeNodes!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

type Entry implements Node {
  _count: EntryCount!
  author: User!
  authorId: String!
  categories: [Category!]
  categoryId: String
  comments: [Comment!]
  content: String
  createdAt: DateTime!
  featuredImage: String
  id: ID!
  published: Boolean
  title: String
  updatedAt: DateTime
}

union EntryCommentUnion = CommentConnection | EntryConnection

type EntryConnection {
  edges: [EntryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type EntryCount {
  categories: Int!
  comments: Int!
}

input EntryCreateManyAuthorInput {
  categoryId: String
  content: String
  createdAt: DateTime
  featuredImage: String
  id: String
  published: Boolean
  title: String!
  updatedAt: DateTime
}

input EntryCreateManyAuthorInputEnvelope {
  data: [EntryCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input EntryCreateNestedManyWithoutAuthorInput {
  connect: [EntryWhereUniqueInput!]
  connectOrCreate: [EntryCreateOrConnectWithoutAuthorInput!]
  create: [EntryCreateWithoutAuthorInput!]
  createMany: EntryCreateManyAuthorInputEnvelope
}

input EntryCreateNestedManyWithoutCategoriesInput {
  connect: [EntryWhereUniqueInput!]
  connectOrCreate: [EntryCreateOrConnectWithoutCategoriesInput!]
  create: [EntryCreateWithoutCategoriesInput!]
}

input EntryCreateNestedOneWithoutCommentsInput {
  connect: EntryWhereUniqueInput
  connectOrCreate: EntryCreateOrConnectWithoutCommentsInput
  create: EntryCreateWithoutCommentsInput
}

input EntryCreateOrConnectWithoutAuthorInput {
  create: EntryCreateWithoutAuthorInput!
  where: EntryWhereUniqueInput!
}

input EntryCreateOrConnectWithoutCategoriesInput {
  create: EntryCreateWithoutCategoriesInput!
  where: EntryWhereUniqueInput!
}

input EntryCreateOrConnectWithoutCommentsInput {
  create: EntryCreateWithoutCommentsInput!
  where: EntryWhereUniqueInput!
}

input EntryCreateWithoutAuthorInput {
  categories: CategoryCreateNestedManyWithoutEntriesInput
  categoryId: String
  comments: CommentCreateNestedManyWithoutEntryInput
  content: String
  createdAt: DateTime
  featuredImage: String
  id: String
  published: Boolean
  title: String!
  updatedAt: DateTime
}

input EntryCreateWithoutCategoriesInput {
  author: UserCreateNestedOneWithoutEntriesInput!
  categoryId: String
  comments: CommentCreateNestedManyWithoutEntryInput
  content: String
  createdAt: DateTime
  featuredImage: String
  id: String
  published: Boolean
  title: String!
  updatedAt: DateTime
}

input EntryCreateWithoutCommentsInput {
  author: UserCreateNestedOneWithoutEntriesInput!
  categories: CategoryCreateNestedManyWithoutEntriesInput
  categoryId: String
  content: String
  createdAt: DateTime
  featuredImage: String
  id: String
  published: Boolean
  title: String!
  updatedAt: DateTime
}

type EntryEdge {
  cursor: String!
  node: Entry!
}

input EntryListRelationFilter {
  every: EntryWhereInput
  none: EntryWhereInput
  some: EntryWhereInput
}

input EntryOrderByRelationAggregateInput {
  _count: SortOrder
}

enum EntryOrderByRelevanceFieldEnum {
  authorId
  categoryId
  content
  featuredImage
  id
  title
}

input EntryOrderByRelevanceInput {
  fields: [EntryOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input EntryOrderByWithRelationAndSearchRelevanceInput {
  _relevance: EntryOrderByRelevanceInput
  author: UserOrderByWithRelationAndSearchRelevanceInput
  authorId: SortOrder
  categories: CategoryOrderByRelationAggregateInput
  categoryId: SortOrder
  comments: CommentOrderByRelationAggregateInput
  content: SortOrder
  createdAt: SortOrder
  featuredImage: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input EntryRelationFilter {
  is: EntryWhereInput
  isNot: EntryWhereInput
}

enum EntryScalarFieldEnum {
  authorId
  categoryId
  content
  createdAt
  featuredImage
  id
  published
  title
  updatedAt
}

input EntryScalarWhereInput {
  AND: [EntryScalarWhereInput!]
  NOT: [EntryScalarWhereInput!]
  OR: [EntryScalarWhereInput!]
  authorId: StringFilter
  categoryId: StringNullableFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  featuredImage: StringNullableFilter
  id: StringFilter
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeNullableFilter
}

input EntryUncheckedCreateNestedManyWithoutAuthorInput {
  connect: [EntryWhereUniqueInput!]
  connectOrCreate: [EntryCreateOrConnectWithoutAuthorInput!]
  create: [EntryCreateWithoutAuthorInput!]
  createMany: EntryCreateManyAuthorInputEnvelope
}

input EntryUpdateManyMutationInput {
  categoryId: NullableStringFieldUpdateOperationsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  featuredImage: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input EntryUpdateManyWithWhereWithoutAuthorInput {
  data: EntryUpdateManyMutationInput!
  where: EntryScalarWhereInput!
}

input EntryUpdateManyWithWhereWithoutCategoriesInput {
  data: EntryUpdateManyMutationInput!
  where: EntryScalarWhereInput!
}

input EntryUpdateManyWithoutAuthorInput {
  connect: [EntryWhereUniqueInput!]
  connectOrCreate: [EntryCreateOrConnectWithoutAuthorInput!]
  create: [EntryCreateWithoutAuthorInput!]
  createMany: EntryCreateManyAuthorInputEnvelope
  delete: [EntryWhereUniqueInput!]
  deleteMany: [EntryScalarWhereInput!]
  disconnect: [EntryWhereUniqueInput!]
  set: [EntryWhereUniqueInput!]
  update: [EntryUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [EntryUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [EntryUpsertWithWhereUniqueWithoutAuthorInput!]
}

input EntryUpdateManyWithoutCategoriesInput {
  connect: [EntryWhereUniqueInput!]
  connectOrCreate: [EntryCreateOrConnectWithoutCategoriesInput!]
  create: [EntryCreateWithoutCategoriesInput!]
  delete: [EntryWhereUniqueInput!]
  deleteMany: [EntryScalarWhereInput!]
  disconnect: [EntryWhereUniqueInput!]
  set: [EntryWhereUniqueInput!]
  update: [EntryUpdateWithWhereUniqueWithoutCategoriesInput!]
  updateMany: [EntryUpdateManyWithWhereWithoutCategoriesInput!]
  upsert: [EntryUpsertWithWhereUniqueWithoutCategoriesInput!]
}

input EntryUpdateOneRequiredWithoutCommentsInput {
  connect: EntryWhereUniqueInput
  connectOrCreate: EntryCreateOrConnectWithoutCommentsInput
  create: EntryCreateWithoutCommentsInput
  update: EntryUpdateWithoutCommentsInput
  upsert: EntryUpsertWithoutCommentsInput
}

input EntryUpdateWithWhereUniqueWithoutAuthorInput {
  data: EntryUpdateWithoutAuthorInput!
  where: EntryWhereUniqueInput!
}

input EntryUpdateWithWhereUniqueWithoutCategoriesInput {
  data: EntryUpdateWithoutCategoriesInput!
  where: EntryWhereUniqueInput!
}

input EntryUpdateWithoutAuthorInput {
  categories: CategoryUpdateManyWithoutEntriesInput
  categoryId: NullableStringFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutEntryInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  featuredImage: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input EntryUpdateWithoutCategoriesInput {
  author: UserUpdateOneRequiredWithoutEntriesInput
  categoryId: NullableStringFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutEntryInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  featuredImage: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input EntryUpdateWithoutCommentsInput {
  author: UserUpdateOneRequiredWithoutEntriesInput
  categories: CategoryUpdateManyWithoutEntriesInput
  categoryId: NullableStringFieldUpdateOperationsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  featuredImage: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input EntryUpsertWithWhereUniqueWithoutAuthorInput {
  create: EntryCreateWithoutAuthorInput!
  update: EntryUpdateWithoutAuthorInput!
  where: EntryWhereUniqueInput!
}

input EntryUpsertWithWhereUniqueWithoutCategoriesInput {
  create: EntryCreateWithoutCategoriesInput!
  update: EntryUpdateWithoutCategoriesInput!
  where: EntryWhereUniqueInput!
}

input EntryUpsertWithoutCommentsInput {
  create: EntryCreateWithoutCommentsInput!
  update: EntryUpdateWithoutCommentsInput!
}

input EntryWhereInput {
  AND: [EntryWhereInput!]
  NOT: [EntryWhereInput!]
  OR: [EntryWhereInput!]
  author: UserRelationFilter
  authorId: StringFilter
  categories: CategoryListRelationFilter
  categoryId: StringNullableFilter
  comments: CommentListRelationFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  featuredImage: StringNullableFilter
  id: StringFilter
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeNullableFilter
}

input EntryWhereUniqueInput {
  authorId: String
  id: String
}

input EnumCommentReactionsNullableListFilter {
  equals: [CommentReactions!]
  has: CommentReactions
  hasEvery: [CommentReactions!]
  hasSome: [CommentReactions!]
  isEmpty: Boolean
}

input EnumGenderNullableFilter {
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderNullableFilter
  notIn: [Gender!]
}

input EnumMediaItemDestinationNullableFilter {
  equals: MediaItemDestination
  in: [MediaItemDestination!]
  not: NestedEnumMediaItemDestinationNullableFilter
  notIn: [MediaItemDestination!]
}

input EnumMimeTypesNullableFilter {
  equals: MimeTypes
  in: [MimeTypes!]
  not: NestedEnumMimeTypesNullableFilter
  notIn: [MimeTypes!]
}

input EnumPronounsNullableFilter {
  equals: Pronouns
  in: [Pronouns!]
  not: NestedEnumPronounsNullableFilter
  notIn: [Pronouns!]
}

input EnumRoleNullableFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleNullableFilter
  notIn: [Role!]
}

input EnumUserStatusNullableFilter {
  equals: UserStatus
  in: [UserStatus!]
  not: NestedEnumUserStatusNullableFilter
  notIn: [UserStatus!]
}

input FindManyCommentsPaginatedInput {
  cursor: CommentWhereUniqueInput
  distinct: [CommentScalarFieldEnum!]
  orderBy: [CommentOrderByWithRelationAndSearchRelevanceInput!]
  pagination: PaginationArgsInput!
  skip: Int
  take: Int
  where: CommentWhereInput
}

input FindManyEntriessPaginatedInput {
  cursor: EntryWhereUniqueInput
  distinct: [EntryScalarFieldEnum!]
  orderBy: [EntryOrderByWithRelationAndSearchRelevanceInput!]
  pagination: PaginationArgsInput!
  skip: Int
  take: Int
  where: EntryWhereInput
}

input FindManyMediaItemsInput {
  cursor: MediaItemWhereUniqueInput
  distinct: [MediaItemScalarFieldEnum!]
  orderBy: [MediaItemOrderByWithRelationAndSearchRelevanceInput!]
  pagination: PaginationArgsInput = {first: 10}
  skip: Int
  take: Int
  where: MediaItemWhereInput
}

input FindManyProfilesPaginatedInput {
  cursor: ProfileWhereUniqueInput
  distinct: [ProfileScalarFieldEnum!]
  orderBy: [ProfileOrderByWithRelationAndSearchRelevanceInput!]
  pagination: PaginationArgsInput!
  skip: Int
  take: Int
  where: ProfileWhereInput
}

input FindManyUsersPaginatedInput {
  cursor: UserWhereUniqueInput
  distinct: [UserScalarFieldEnum!]
  orderBy: [UserOrderByWithRelationAndSearchRelevanceInput!]!
  pagination: PaginationArgsInput = {first: 10}
  skip: Int
  take: Int
  where: UserWhereInput
}

input FindViewerEntriesPaginatedInput {
  cursor: EntryWhereUniqueInput
  distinct: [EntryScalarFieldEnum!]
  orderBy: [EntryOrderByWithRelationAndSearchRelevanceInput!]
  pagination: PaginationArgsInput!
  skip: Int
  take: Int
  unique: EntryWhereUniqueInput
  where: ViewerEntriesWhereInput
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

enum Gender {
  FEMALE
  MALE
  OTHER
  UNCERTAIN
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

type JwtDecoded {
  header: JwtHeaders!
  payload: JwtPayload!
  signature: String!
}

type JwtHeaders {
  alg: AlgorithmType!
  typ: String!
}

type JwtPayload {
  exp: BigInt
  iat: BigInt
  userId: String
}

input LoginInput {
  email: String
  password: String
}

type MediaItem implements Node {
  fileLastModified: DateTime
  height: Float
  id: ID!
  name: String
  quality: Int
  size: String
  src: String
  srcSet: String
  type: MimeTypes
  updatedAt: DateTime
  uploadedAt: DateTime!
  user: User!
  userId: String!
  width: Float
}

type MediaItemConnection {
  edges: [MediaItemEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input MediaItemCreateManyUserInput {
  ariaLabel: String
  caption: String
  destination: MediaItemDestination
  fileLastModified: DateTime
  height: Float
  id: String
  name: String
  quality: Int
  size: String
  src: String
  srcSet: String
  title: String
  type: MimeTypes
  updatedAt: DateTime
  uploadedAt: DateTime
  width: Float
}

input MediaItemCreateManyUserInputEnvelope {
  data: [MediaItemCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input MediaItemCreateNestedManyWithoutUserInput {
  connect: [MediaItemWhereUniqueInput!]
  connectOrCreate: [MediaItemCreateOrConnectWithoutUserInput!]
  create: [MediaItemCreateWithoutUserInput!]
  createMany: MediaItemCreateManyUserInputEnvelope
}

input MediaItemCreateOrConnectWithoutUserInput {
  create: MediaItemCreateWithoutUserInput!
  where: MediaItemWhereUniqueInput!
}

input MediaItemCreateWithoutUserInput {
  ariaLabel: String
  caption: String
  destination: MediaItemDestination
  fileLastModified: DateTime
  height: Float
  id: String
  name: String
  quality: Int
  size: String
  src: String
  srcSet: String
  title: String
  type: MimeTypes
  updatedAt: DateTime
  uploadedAt: DateTime
  width: Float
}

enum MediaItemDestination {
  AVATAR
  COMMENT_ATTACHMENT
  COVER_IMAGE
  ENTRY_ATTACHMENT
  FEATURED_IMAGE
}

type MediaItemEdge {
  cursor: String!
  node: MediaItem!
}

input MediaItemListRelationFilter {
  every: MediaItemWhereInput
  none: MediaItemWhereInput
  some: MediaItemWhereInput
}

input MediaItemNameUserIdCompoundUniqueInput {
  name: String!
  userId: String!
}

input MediaItemOrderByRelationAggregateInput {
  _count: SortOrder
}

enum MediaItemOrderByRelevanceFieldEnum {
  ariaLabel
  caption
  id
  name
  size
  src
  srcSet
  title
  userId
}

input MediaItemOrderByRelevanceInput {
  fields: [MediaItemOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input MediaItemOrderByWithRelationAndSearchRelevanceInput {
  _relevance: MediaItemOrderByRelevanceInput
  ariaLabel: SortOrder
  caption: SortOrder
  destination: SortOrder
  fileLastModified: SortOrder
  height: SortOrder
  id: SortOrder
  name: SortOrder
  quality: SortOrder
  size: SortOrder
  src: SortOrder
  srcSet: SortOrder
  title: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  uploadedAt: SortOrder
  user: UserOrderByWithRelationAndSearchRelevanceInput
  userId: SortOrder
  width: SortOrder
}

enum MediaItemScalarFieldEnum {
  ariaLabel
  caption
  destination
  fileLastModified
  height
  id
  name
  quality
  size
  src
  srcSet
  title
  type
  updatedAt
  uploadedAt
  userId
  width
}

input MediaItemScalarWhereInput {
  AND: [MediaItemScalarWhereInput!]
  NOT: [MediaItemScalarWhereInput!]
  OR: [MediaItemScalarWhereInput!]
  ariaLabel: StringNullableFilter
  caption: StringNullableFilter
  destination: EnumMediaItemDestinationNullableFilter
  fileLastModified: DateTimeNullableFilter
  height: FloatNullableFilter
  id: StringFilter
  name: StringNullableFilter
  quality: IntNullableFilter
  size: StringNullableFilter
  src: StringNullableFilter
  srcSet: StringNullableFilter
  title: StringNullableFilter
  type: EnumMimeTypesNullableFilter
  updatedAt: DateTimeNullableFilter
  uploadedAt: DateTimeFilter
  userId: StringFilter
  width: FloatNullableFilter
}

input MediaItemUpdateManyMutationInput {
  ariaLabel: NullableStringFieldUpdateOperationsInput
  caption: NullableStringFieldUpdateOperationsInput
  destination: NullableEnumMediaItemDestinationFieldUpdateOperationsInput
  fileLastModified: NullableDateTimeFieldUpdateOperationsInput
  height: NullableFloatFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  quality: NullableIntFieldUpdateOperationsInput
  size: NullableStringFieldUpdateOperationsInput
  src: NullableStringFieldUpdateOperationsInput
  srcSet: NullableStringFieldUpdateOperationsInput
  title: NullableStringFieldUpdateOperationsInput
  type: NullableEnumMimeTypesFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  uploadedAt: DateTimeFieldUpdateOperationsInput
  width: NullableFloatFieldUpdateOperationsInput
}

input MediaItemUpdateManyWithWhereWithoutUserInput {
  data: MediaItemUpdateManyMutationInput!
  where: MediaItemScalarWhereInput!
}

input MediaItemUpdateManyWithoutUserInput {
  connect: [MediaItemWhereUniqueInput!]
  connectOrCreate: [MediaItemCreateOrConnectWithoutUserInput!]
  create: [MediaItemCreateWithoutUserInput!]
  createMany: MediaItemCreateManyUserInputEnvelope
  delete: [MediaItemWhereUniqueInput!]
  deleteMany: [MediaItemScalarWhereInput!]
  disconnect: [MediaItemWhereUniqueInput!]
  set: [MediaItemWhereUniqueInput!]
  update: [MediaItemUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [MediaItemUpdateManyWithWhereWithoutUserInput!]
  upsert: [MediaItemUpsertWithWhereUniqueWithoutUserInput!]
}

input MediaItemUpdateWithWhereUniqueWithoutUserInput {
  data: MediaItemUpdateWithoutUserInput!
  where: MediaItemWhereUniqueInput!
}

input MediaItemUpdateWithoutUserInput {
  ariaLabel: NullableStringFieldUpdateOperationsInput
  caption: NullableStringFieldUpdateOperationsInput
  destination: NullableEnumMediaItemDestinationFieldUpdateOperationsInput
  fileLastModified: NullableDateTimeFieldUpdateOperationsInput
  height: NullableFloatFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  quality: NullableIntFieldUpdateOperationsInput
  size: NullableStringFieldUpdateOperationsInput
  src: NullableStringFieldUpdateOperationsInput
  srcSet: NullableStringFieldUpdateOperationsInput
  title: NullableStringFieldUpdateOperationsInput
  type: NullableEnumMimeTypesFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  uploadedAt: DateTimeFieldUpdateOperationsInput
  width: NullableFloatFieldUpdateOperationsInput
}

input MediaItemUpsertWithWhereUniqueWithoutUserInput {
  create: MediaItemCreateWithoutUserInput!
  update: MediaItemUpdateWithoutUserInput!
  where: MediaItemWhereUniqueInput!
}

input MediaItemWhereInput {
  AND: [MediaItemWhereInput!]
  NOT: [MediaItemWhereInput!]
  OR: [MediaItemWhereInput!]
  ariaLabel: StringNullableFilter
  caption: StringNullableFilter
  destination: EnumMediaItemDestinationNullableFilter
  fileLastModified: DateTimeNullableFilter
  height: FloatNullableFilter
  id: StringFilter
  name: StringNullableFilter
  quality: IntNullableFilter
  size: StringNullableFilter
  src: StringNullableFilter
  srcSet: StringNullableFilter
  title: StringNullableFilter
  type: EnumMimeTypesNullableFilter
  updatedAt: DateTimeNullableFilter
  uploadedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
  width: FloatNullableFilter
}

input MediaItemWhereUniqueInput {
  id: String
  name_userId: MediaItemNameUserIdCompoundUniqueInput
}

enum MimeTypes {
  AVIF
  BMP
  GIF
  JPEG
  PNG
  SVG
  TIFF
  WEBP
}

type Mutation {
  changePassword(changePasswordInput: ChangePasswordInput!): User!
  createEntry(EntryInput: EntryUncheckedCreateNestedManyWithoutAuthorInput!): Entry!
  createNewEntry(createNewEntryInput: EntryUncheckedCreateNestedManyWithoutAuthorInput!): Entry!
  createProfile(data: ProfileCreateInput!, userId: String!): Profile!
  login(data: LoginInput!): Token!
  register(dataRegister: SignupInput!): AuthSansSession!
  registerNewUser(userCreateInput: UserCreateMutationInput!): AuthDetailed!
  signin(userloginInput: LoginInput!): AuthDetailed!
  signup(data: SignupInput!): Token!
  updateUserPassword(passwordInput: ChangePasswordInput!): User!
  upsertComment(commentUpsertInput: CommentUpsertWithWhereUniqueWithoutAuthorInput!): [Comment!]!
  userFromAccessTokenDecoded(token: String!): AuthDetailed!
  viewerCreateEntry(viewerEntryCreateInput: EntryUpdateManyWithWhereWithoutAuthorInput!): [Entry!]!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedEnumGenderNullableFilter {
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderNullableFilter
  notIn: [Gender!]
}

input NestedEnumMediaItemDestinationNullableFilter {
  equals: MediaItemDestination
  in: [MediaItemDestination!]
  not: NestedEnumMediaItemDestinationNullableFilter
  notIn: [MediaItemDestination!]
}

input NestedEnumMimeTypesNullableFilter {
  equals: MimeTypes
  in: [MimeTypes!]
  not: NestedEnumMimeTypesNullableFilter
  notIn: [MimeTypes!]
}

input NestedEnumPronounsNullableFilter {
  equals: Pronouns
  in: [Pronouns!]
  not: NestedEnumPronounsNullableFilter
  notIn: [Pronouns!]
}

input NestedEnumRoleNullableFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleNullableFilter
  notIn: [Role!]
}

input NestedEnumUserStatusNullableFilter {
  equals: UserStatus
  in: [UserStatus!]
  not: NestedEnumUserStatusNullableFilter
  notIn: [UserStatus!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

interface Node {
  id: ID!
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableEnumGenderFieldUpdateOperationsInput {
  set: Gender
}

input NullableEnumMediaItemDestinationFieldUpdateOperationsInput {
  set: MediaItemDestination
}

input NullableEnumMimeTypesFieldUpdateOperationsInput {
  set: MimeTypes
}

input NullableEnumPronounsFieldUpdateOperationsInput {
  set: Pronouns
}

input NullableEnumRoleFieldUpdateOperationsInput {
  set: Role
}

input NullableEnumUserStatusFieldUpdateOperationsInput {
  set: UserStatus
}

input NullableFloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PaginationArgsInput {
  after: String = null
  before: String = null
  first: Int = 10
  last: Int = null
}

"""
A field whose value conforms to the standard E.164 format as specified in: https://en.wikipedia.org/wiki/E.164. Basically this is +17895551234.
"""
scalar PhoneNumber

type Profile implements Node {
  activiyFeed: String
  bio: String
  city: String
  country: String
  coverPhoto: String
  dob: String
  gender: Gender
  id: ID!
  lastSeen: DateTime
  memberSince: DateTime!
  occupation: String
  phoneNumber: String
  pronouns: Pronouns
  recentActivity: String
  user: User!
  userId: String!
  userInProfile: User!
}

type ProfileConnection {
  edges: [ProfileEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ProfileCreateInput {
  activiyFeed: String
  bio: String
  city: String
  country: String
  coverPhoto: String
  dob: String
  gender: Gender
  id: String
  lastSeen: DateTime
  memberSince: DateTime
  occupation: String
  phoneNumber: String
  pronouns: Pronouns
  recentActivity: String
  user: UserCreateNestedOneWithoutProfileInput!
}

input ProfileCreateNestedOneWithoutUserInput {
  connect: ProfileWhereUniqueInput
  connectOrCreate: ProfileCreateOrConnectWithoutUserInput
  create: ProfileCreateWithoutUserInput
}

input ProfileCreateOrConnectWithoutUserInput {
  create: ProfileCreateWithoutUserInput!
  where: ProfileWhereUniqueInput!
}

input ProfileCreateWithoutUserInput {
  activiyFeed: String
  bio: String
  city: String
  country: String
  coverPhoto: String
  dob: String
  gender: Gender
  id: String
  lastSeen: DateTime
  memberSince: DateTime
  occupation: String
  phoneNumber: String
  pronouns: Pronouns
  recentActivity: String
}

type ProfileEdge {
  cursor: String!
  node: Profile!
}

enum ProfileOrderByRelevanceFieldEnum {
  activiyFeed
  bio
  city
  country
  coverPhoto
  dob
  id
  occupation
  phoneNumber
  recentActivity
  userId
}

input ProfileOrderByRelevanceInput {
  fields: [ProfileOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input ProfileOrderByWithRelationAndSearchRelevanceInput {
  _relevance: ProfileOrderByRelevanceInput
  activiyFeed: SortOrder
  bio: SortOrder
  city: SortOrder
  country: SortOrder
  coverPhoto: SortOrder
  dob: SortOrder
  gender: SortOrder
  id: SortOrder
  lastSeen: SortOrder
  memberSince: SortOrder
  occupation: SortOrder
  phoneNumber: SortOrder
  pronouns: SortOrder
  recentActivity: SortOrder
  user: UserOrderByWithRelationAndSearchRelevanceInput
  userId: SortOrder
}

input ProfileRelationFilter {
  is: ProfileWhereInput
  isNot: ProfileWhereInput
}

enum ProfileScalarFieldEnum {
  activiyFeed
  bio
  city
  country
  coverPhoto
  dob
  gender
  id
  lastSeen
  memberSince
  occupation
  phoneNumber
  pronouns
  recentActivity
  userId
}

input ProfileUpdateOneWithoutUserInput {
  connect: ProfileWhereUniqueInput
  connectOrCreate: ProfileCreateOrConnectWithoutUserInput
  create: ProfileCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: ProfileUpdateWithoutUserInput
  upsert: ProfileUpsertWithoutUserInput
}

input ProfileUpdateWithoutUserInput {
  activiyFeed: NullableStringFieldUpdateOperationsInput
  bio: NullableStringFieldUpdateOperationsInput
  city: NullableStringFieldUpdateOperationsInput
  country: NullableStringFieldUpdateOperationsInput
  coverPhoto: NullableStringFieldUpdateOperationsInput
  dob: NullableStringFieldUpdateOperationsInput
  gender: NullableEnumGenderFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastSeen: NullableDateTimeFieldUpdateOperationsInput
  memberSince: DateTimeFieldUpdateOperationsInput
  occupation: NullableStringFieldUpdateOperationsInput
  phoneNumber: NullableStringFieldUpdateOperationsInput
  pronouns: NullableEnumPronounsFieldUpdateOperationsInput
  recentActivity: NullableStringFieldUpdateOperationsInput
}

input ProfileUpsertWithoutUserInput {
  create: ProfileCreateWithoutUserInput!
  update: ProfileUpdateWithoutUserInput!
}

input ProfileWhereInput {
  AND: [ProfileWhereInput!]
  NOT: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  activiyFeed: StringNullableFilter
  bio: StringNullableFilter
  city: StringNullableFilter
  country: StringNullableFilter
  coverPhoto: StringNullableFilter
  dob: StringNullableFilter
  gender: EnumGenderNullableFilter
  id: StringFilter
  lastSeen: DateTimeNullableFilter
  memberSince: DateTimeFilter
  occupation: StringNullableFilter
  phoneNumber: StringNullableFilter
  pronouns: EnumPronounsNullableFilter
  recentActivity: StringNullableFilter
  user: UserRelationFilter
  userId: StringFilter
}

input ProfileWhereUniqueInput {
  id: String
  userId: String
}

input ProfilesInput {
  bioFilter: StringNullableFilter
  dobFilter: StringNullableFilter
  genderFilter: EnumGenderNullableFilter
  orderBy: ProfileOrderByWithRelationAndSearchRelevanceInput
  paginationArgs: PaginationArgsInput
  pronounsFilter: EnumPronounsNullableFilter
}

enum Pronouns {
  HE_HIM_HIS
  NOT_LISTED
  PREFER_NOT_TO_SAY
  SHE_HER_HERS
  THEY_THEM_THEIRS
}

type Query {
  commentByRelayId(cursor: String!): Comment!
  commentConnectionUnion(findManyCommentsPaginatedInput: FindManyCommentsPaginatedInput!, findManyEntriesPaginatedInput: FindManyEntriessPaginatedInput!): [EntryCommentUnion!]!
  contentNodesUnion(findManyEntriesPaginatedInput: FindManyEntriessPaginatedInput!, findManyMediaItemsPaginated: FindManyMediaItemsInput, findManyUsersPaginatedInput: FindManyUsersPaginatedInput): ContentNodes!
  entryById(id: String!): Entry!
  findUniqueMediaItem(mediaItemId: String!): MediaItem!
  getUserFromAccessToken(token: String!): User!
  getViewer: AuthDetailed!
  hello(name: String!): String!
  helloWorld: String!
  listComments(findManyCommentsPaginatedInput: FindManyCommentsPaginatedInput!): CommentConnection!
  listEntries(findManyEntriesPaginatedInput: FindManyEntriessPaginatedInput!): EntryConnection!
  listMediaItems(findManyMediaItemsPaginated: FindManyMediaItemsInput): MediaItemConnection!
  listProfiles(findManyProfilesPaginatedInput: FindManyProfilesPaginatedInput!): ProfileConnection!
  listUsers(findManyUsersPaginatedInput: FindManyUsersPaginatedInput = {}): UserConnection!
  me: AuthDetailed!
  node(id: ID!): Node
  profileByRelayId: Profile!
  profiles(profilesArgs: ProfilesInput!): ProfileConnection!
  siftEntries(entryFindManyInput: FindManyEntriessPaginatedInput!): EntryConnection!
  userById(id: String!): User!
  userByRelayId(cursor: String!): User!
  viewer: ViewerDetailed!
  viewerAuthInfoFromContext: ViewerAuthInfo!
  viewerEntriesPaginated(viewerEntriesPaginatedInput: FindViewerEntriesPaginatedInput!): EntryConnection!
}

enum QueryMode {
  default
  insensitive
}

enum Role {
  ADMIN
  MAINTAINER
  SUPERADMIN
  USER
}

type Session implements Node {
  accessToken: String
  alg: String
  exp: Int
  iat: Int
  id: ID!
  lastVerified: DateTime
  provider: String
  refreshToken: String
  scopes: [String!]
  signature: String
  tokenState: String
  user: User
  userId: String!
}

input SessionCreateManyUserInput {
  accessToken: String
  alg: String
  exp: Int
  iat: Int
  id: String
  lastVerified: DateTime
  provider: String
  refreshToken: String
  scopes: SessionCreateManyscopesInput
  signature: String
  tokenState: String
}

input SessionCreateManyUserInputEnvelope {
  data: [SessionCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input SessionCreateManyscopesInput {
  set: [String!]!
}

input SessionCreateNestedManyWithoutUserInput {
  connect: [SessionWhereUniqueInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  create: [SessionCreateWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
}

input SessionCreateOrConnectWithoutUserInput {
  create: SessionCreateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionCreateWithoutUserInput {
  accessToken: String
  alg: String
  exp: Int
  iat: Int
  id: String
  lastVerified: DateTime
  provider: String
  refreshToken: String
  scopes: SessionCreatescopesInput
  signature: String
  tokenState: String
}

input SessionCreatescopesInput {
  set: [String!]!
}

input SessionListRelationFilter {
  every: SessionWhereInput
  none: SessionWhereInput
  some: SessionWhereInput
}

input SessionOrderByRelationAggregateInput {
  _count: SortOrder
}

input SessionScalarWhereInput {
  AND: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  accessToken: StringNullableFilter
  alg: StringNullableFilter
  exp: IntNullableFilter
  iat: IntNullableFilter
  id: StringFilter
  lastVerified: DateTimeNullableFilter
  provider: StringNullableFilter
  refreshToken: StringNullableFilter
  scopes: StringNullableListFilter
  signature: StringNullableFilter
  tokenState: StringNullableFilter
  userId: StringFilter
}

input SessionUpdateManyMutationInput {
  accessToken: NullableStringFieldUpdateOperationsInput
  alg: NullableStringFieldUpdateOperationsInput
  exp: NullableIntFieldUpdateOperationsInput
  iat: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastVerified: NullableDateTimeFieldUpdateOperationsInput
  provider: NullableStringFieldUpdateOperationsInput
  refreshToken: NullableStringFieldUpdateOperationsInput
  scopes: SessionUpdatescopesInput
  signature: NullableStringFieldUpdateOperationsInput
  tokenState: NullableStringFieldUpdateOperationsInput
}

input SessionUpdateManyWithWhereWithoutUserInput {
  data: SessionUpdateManyMutationInput!
  where: SessionScalarWhereInput!
}

input SessionUpdateManyWithoutUserInput {
  connect: [SessionWhereUniqueInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  create: [SessionCreateWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
  delete: [SessionWhereUniqueInput!]
  deleteMany: [SessionScalarWhereInput!]
  disconnect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [SessionUpdateManyWithWhereWithoutUserInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutUserInput!]
}

input SessionUpdateWithWhereUniqueWithoutUserInput {
  data: SessionUpdateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionUpdateWithoutUserInput {
  accessToken: NullableStringFieldUpdateOperationsInput
  alg: NullableStringFieldUpdateOperationsInput
  exp: NullableIntFieldUpdateOperationsInput
  iat: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastVerified: NullableDateTimeFieldUpdateOperationsInput
  provider: NullableStringFieldUpdateOperationsInput
  refreshToken: NullableStringFieldUpdateOperationsInput
  scopes: SessionUpdatescopesInput
  signature: NullableStringFieldUpdateOperationsInput
  tokenState: NullableStringFieldUpdateOperationsInput
}

input SessionUpdatescopesInput {
  push: [String!]
  set: [String!]
}

input SessionUpsertWithWhereUniqueWithoutUserInput {
  create: SessionCreateWithoutUserInput!
  update: SessionUpdateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionWhereInput {
  AND: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  accessToken: StringNullableFilter
  alg: StringNullableFilter
  exp: IntNullableFilter
  iat: IntNullableFilter
  id: StringFilter
  lastVerified: DateTimeNullableFilter
  provider: StringNullableFilter
  refreshToken: StringNullableFilter
  scopes: StringNullableListFilter
  signature: StringNullableFilter
  tokenState: StringNullableFilter
  user: UserRelationFilter
  userId: StringFilter
}

input SessionWhereUniqueInput {
  userId: String
}

input SignupInput {
  email: String!
  firstName: String
  image: String
  lastName: String
  password: String!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

type Subscription {
  entryCreated: Entry!
  profileCreated: Profile!
}

type Token {
  """JWT access token"""
  accessToken: String

  """JWT refresh token"""
  refreshToken: String
}

union TypesUnion = Entry | MediaItem | User

type User implements Node {
  _count: UserCount
  accounts: [Account!]
  categories: [Category!]
  comments: [Comment!]
  connections: [Connection!]

  """Identifies the date and time when the user was created."""
  createdAt: DateTime!
  email: String!
  emailVerified: DateTime
  entries: [Entry!]
  firstName: String
  id: ID!
  image: String
  lastName: String
  mediaItems: [MediaItem!]
  password: String!
  profile: Profile
  role: Role
  sessions: [Session!]
  status: UserStatus!

  """Identifies the date and time when the user was last updated."""
  updatedAt: DateTime
}

type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserCount {
  accounts: Int!
  categories: Int!
  comments: Int!
  connections: Int!
  entries: Int!
  mediaItems: Int!
  sessions: Int!
}

input UserCreateMutationInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  categories: CategoryCreateNestedManyWithoutCreatorInput
  comments: CommentCreateNestedManyWithoutAuthorInput
  connections: ConnectionCreateNestedManyWithoutOwnerInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  entries: EntryCreateNestedManyWithoutAuthorInput
  firstName: String
  id: ID
  image: String
  lastName: String
  mediaItems: MediaItemCreateNestedManyWithoutUserInput
  password: String
  profile: ProfileCreateNestedOneWithoutUserInput
  role: Role
  sessions: SessionCreateNestedManyWithoutUserInput
  status: UserStatus
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutCategoriesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCategoriesInput
  create: UserCreateWithoutCategoriesInput
}

input UserCreateNestedOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserCreateWithoutCommentsInput
}

input UserCreateNestedOneWithoutEntriesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutEntriesInput
  create: UserCreateWithoutEntriesInput
}

input UserCreateNestedOneWithoutProfileInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProfileInput
  create: UserCreateWithoutProfileInput
}

input UserCreateOrConnectWithoutCategoriesInput {
  create: UserCreateWithoutCategoriesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutEntriesInput {
  create: UserCreateWithoutEntriesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutProfileInput {
  create: UserCreateWithoutProfileInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutCategoriesInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutAuthorInput
  connections: ConnectionCreateNestedManyWithoutOwnerInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  entries: EntryCreateNestedManyWithoutAuthorInput
  firstName: String
  id: String
  image: String
  lastName: String
  mediaItems: MediaItemCreateNestedManyWithoutUserInput
  password: String
  profile: ProfileCreateNestedOneWithoutUserInput
  role: Role
  sessions: SessionCreateNestedManyWithoutUserInput
  status: UserStatus
  updatedAt: DateTime
}

input UserCreateWithoutCommentsInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  categories: CategoryCreateNestedManyWithoutCreatorInput
  connections: ConnectionCreateNestedManyWithoutOwnerInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  entries: EntryCreateNestedManyWithoutAuthorInput
  firstName: String
  id: String
  image: String
  lastName: String
  mediaItems: MediaItemCreateNestedManyWithoutUserInput
  password: String
  profile: ProfileCreateNestedOneWithoutUserInput
  role: Role
  sessions: SessionCreateNestedManyWithoutUserInput
  status: UserStatus
  updatedAt: DateTime
}

input UserCreateWithoutEntriesInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  categories: CategoryCreateNestedManyWithoutCreatorInput
  comments: CommentCreateNestedManyWithoutAuthorInput
  connections: ConnectionCreateNestedManyWithoutOwnerInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  firstName: String
  id: String
  image: String
  lastName: String
  mediaItems: MediaItemCreateNestedManyWithoutUserInput
  password: String
  profile: ProfileCreateNestedOneWithoutUserInput
  role: Role
  sessions: SessionCreateNestedManyWithoutUserInput
  status: UserStatus
  updatedAt: DateTime
}

input UserCreateWithoutProfileInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  categories: CategoryCreateNestedManyWithoutCreatorInput
  comments: CommentCreateNestedManyWithoutAuthorInput
  connections: ConnectionCreateNestedManyWithoutOwnerInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  entries: EntryCreateNestedManyWithoutAuthorInput
  firstName: String
  id: String
  image: String
  lastName: String
  mediaItems: MediaItemCreateNestedManyWithoutUserInput
  password: String
  role: Role
  sessions: SessionCreateNestedManyWithoutUserInput
  status: UserStatus
  updatedAt: DateTime
}

type UserEdge {
  cursor: String!
  node: User!
}

enum UserOrderByRelevanceFieldEnum {
  email
  firstName
  id
  image
  lastName
  password
}

input UserOrderByRelevanceInput {
  fields: [UserOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input UserOrderByWithRelationAndSearchRelevanceInput {
  _relevance: UserOrderByRelevanceInput
  accounts: AccountOrderByRelationAggregateInput
  categories: CategoryOrderByRelationAggregateInput
  comments: CommentOrderByRelationAggregateInput
  connections: ConnectionOrderByRelationAggregateInput
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  entries: EntryOrderByRelationAggregateInput
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  lastName: SortOrder
  mediaItems: MediaItemOrderByRelationAggregateInput
  password: SortOrder
  profile: ProfileOrderByWithRelationAndSearchRelevanceInput
  role: SortOrder
  sessions: SessionOrderByRelationAggregateInput
  status: SortOrder
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  emailVerified
  firstName
  id
  image
  lastName
  password
  role
  status
  updatedAt
}

enum UserStatus {
  BANNED
  DEACTIVATED
  DELETED
  OFFLINE
  ONLINE
  SUSPENDED
}

input UserUpdateOneRequiredWithoutCategoriesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCategoriesInput
  create: UserCreateWithoutCategoriesInput
  update: UserUpdateWithoutCategoriesInput
  upsert: UserUpsertWithoutCategoriesInput
}

input UserUpdateOneRequiredWithoutCommentsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserCreateWithoutCommentsInput
  update: UserUpdateWithoutCommentsInput
  upsert: UserUpsertWithoutCommentsInput
}

input UserUpdateOneRequiredWithoutEntriesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutEntriesInput
  create: UserCreateWithoutEntriesInput
  update: UserUpdateWithoutEntriesInput
  upsert: UserUpsertWithoutEntriesInput
}

input UserUpdateWithoutCategoriesInput {
  accounts: AccountUpdateManyWithoutUserInput
  comments: CommentUpdateManyWithoutAuthorInput
  connections: ConnectionUpdateManyWithoutOwnerInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  entries: EntryUpdateManyWithoutAuthorInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  mediaItems: MediaItemUpdateManyWithoutUserInput
  password: StringFieldUpdateOperationsInput
  profile: ProfileUpdateOneWithoutUserInput
  role: NullableEnumRoleFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserInput
  status: NullableEnumUserStatusFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutCommentsInput {
  accounts: AccountUpdateManyWithoutUserInput
  categories: CategoryUpdateManyWithoutCreatorInput
  connections: ConnectionUpdateManyWithoutOwnerInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  entries: EntryUpdateManyWithoutAuthorInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  mediaItems: MediaItemUpdateManyWithoutUserInput
  password: StringFieldUpdateOperationsInput
  profile: ProfileUpdateOneWithoutUserInput
  role: NullableEnumRoleFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserInput
  status: NullableEnumUserStatusFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutEntriesInput {
  accounts: AccountUpdateManyWithoutUserInput
  categories: CategoryUpdateManyWithoutCreatorInput
  comments: CommentUpdateManyWithoutAuthorInput
  connections: ConnectionUpdateManyWithoutOwnerInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  mediaItems: MediaItemUpdateManyWithoutUserInput
  password: StringFieldUpdateOperationsInput
  profile: ProfileUpdateOneWithoutUserInput
  role: NullableEnumRoleFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserInput
  status: NullableEnumUserStatusFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutCategoriesInput {
  create: UserCreateWithoutCategoriesInput!
  update: UserUpdateWithoutCategoriesInput!
}

input UserUpsertWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  update: UserUpdateWithoutCommentsInput!
}

input UserUpsertWithoutEntriesInput {
  create: UserCreateWithoutEntriesInput!
  update: UserUpdateWithoutEntriesInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  accounts: AccountListRelationFilter
  categories: CategoryListRelationFilter
  comments: CommentListRelationFilter
  connections: ConnectionListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  emailVerified: DateTimeNullableFilter
  entries: EntryListRelationFilter
  firstName: StringNullableFilter
  id: StringFilter
  image: StringNullableFilter
  lastName: StringNullableFilter
  mediaItems: MediaItemListRelationFilter
  password: StringFilter
  profile: ProfileRelationFilter
  role: EnumRoleNullableFilter
  sessions: SessionListRelationFilter
  status: EnumUserStatusNullableFilter
  updatedAt: DateTimeNullableFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}

type ViewerAuthInfo {
  accessToken: String!
  refreshToken: String!
  viewerJwt: JwtDecoded!
}

type ViewerDetailed implements Node {
  _count: UserCount
  accessToken: String
  accounts: [Account!]
  categories: [Category!]
  comments: [Comment!]
  connections: [Connection!]

  """Identifies the date and time when the user was created."""
  createdAt: DateTime!
  email: String!
  emailVerified: DateTime
  entries: [Entry!]
  firstName: String
  id: ID!
  image: String
  lastName: String
  mediaItems: [MediaItem!]
  password: String!
  profile: Profile
  refreshToken: String
  role: Role
  secret: String
  sessions: [Session!]
  status: UserStatus!

  """Identifies the date and time when the user was last updated."""
  updatedAt: DateTime
}

input ViewerEntriesWhereInput {
  AND: [ViewerEntriesWhereInput!]
  NOT: [ViewerEntriesWhereInput!]
  OR: [ViewerEntriesWhereInput!]
  categories: CategoryListRelationFilter
  categoryId: StringNullableFilter
  comments: CommentListRelationFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  featuredImage: StringNullableFilter
  id: StringFilter
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeNullableFilter
}
